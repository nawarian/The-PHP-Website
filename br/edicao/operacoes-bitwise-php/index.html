<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <link rel="stylesheet" href="/assets/build/css/main.css?id=2e42c8808e21522a0c4d">
      <link rel="canonical" href="https://thephp.website/br/edicao/operacoes-bitwise-php/" />
      <link
    rel="alternate"
    type="application/json"
    title="[BR] thePHP Website"
    href="https://thephp.website/br/feed.json"
  />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="[BR] thePHP Website"
    href="https://thephp.website/br/feed.xml"
  />
  
  <title>Opera√ß√µes bin√°rias (bitwise) com PHP | thePHP Website</title>

  <meta name="description" content="Recentemente eu trabalhei em diferentes projetos que me for√ßaram a usar bastante opera√ß√µes com bin√°rios em PHP. De ler arquivos a emular processadores, este √© um conhecimento interessant√≠ssimo e muito √∫til.">

  <meta property="og:title" content="Opera√ß√µes bin√°rias (bitwise) com PHP">
  <meta property="og:description" content="Recentemente eu trabalhei em diferentes projetos que me for√ßaram a usar bastante opera√ß√µes com bin√°rios em PHP. De ler arquivos a emular processadores, este √© um conhecimento interessant√≠ssimo e muito √∫til.">
  <meta property="og:url" content="https://thephp.website/br/edicao/operacoes-bitwise-php">
  <meta property="og:image" content="https://thephp.website/assets/images/posts/20-bitwise-php/cover-640.webp">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@nawarian">
  <meta name="twitter:title" content="Opera√ß√µes bin√°rias (bitwise) com PHP">
  <meta name="twitter:description" content="Recentemente eu trabalhei em diferentes projetos que me for√ßaram a usar bastante opera√ß√µes com bin√°rios em PHP. De ler arquivos a emular processadores, este √© um conhecimento interessant√≠ssimo e muito √∫til.">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151169766-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-151169766-3');
  </script>
  <script data-ad-client="ca-pub-3681134868307419" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- Hotjar Tracking Code for thephp.website -->
  <script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1770868,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
  </script>
  <script>
    function toggleMenu() {
      document.querySelector('.menu__container').classList.toggle('menu__container--active');
    }
  </script>
</head>
<body class="yue non-article">
  <header class="menu">
    <a class="menu__logo" href="/br/">
      <img src="/assets/images/elephpant-idle.png" alt="" />
    </a>
    <div class="menu__title">
      <a href="/br/">thePHP Website</a>
    </div>
    <section class="menu__cta">
      <button role="button" aria-label="Open Menu" class="menu__cta__icon" onclick="typeof toggleMenu == 'function' &amp;&amp; toggleMenu()">
        <img alt="Open Menu" src="https://podentender.com.br/assets/images/icons/menu.svg">
      </button>
    </section>

    <div class="menu__container">
      <em class="menu__section-heading">
        Pages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/br/">Home</a>
        </li>
        <li class="menu__list-item">
          <a href="/br/busca">
            busca.php
          </a>
        </li>
        <li class="menu__list-item">
          <a
            href="https://github.com/nawarian/The-PHP-Website/issues/new?title=[Suggested+Topic]%20&body=Please+describe+your+suggestion+/+Por+favor+descreva+sua+sugest√£o"
            rel="nofollow"
          >
            Pe√ßa um Post!
          </a>
        </li>
        <li class="menu__list-item">
          <a href="/br/sobre/">
            sobre.php
          </a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Languages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/en/">English</a>
        </li>
        <li class="menu__list-item">
          <a href="/br/">Portugu√™s</a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Notifications.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="https://thephp.website/br/feed.json">
            [BR] JSON Feed
          </a>
        </li>
        <li class="menu__list-item">
          <a href="https://thephp.website/br/feed.xml">
            [BR] Atom Feed (RSS)
          </a>
        </li>
                <li class="menu__list-item">
          <a href="https://thephp.website/br/feed-vagas.xml">
            Feed de Vagas (RSS)
          </a>
        </li>
              </ul>
    </div>
  </header>
  <article class="container">
      <div class="article">
    <time datetime="2021-02-24">
      2021-02-24
    </time>

    <h1>Opera√ß√µes bin√°rias (bitwise) com PHP</h1>
    <p><a href="/en/issue/bitwise-php/">Read in English</a></p>

<p>Recentemente eu trabalhei em diferentes projetos que me for√ßaram a usar bastante opera√ß√µes com bin√°rios em PHP. De ler arquivos a emular processadores, este √© um conhecimento interessant√≠ssimo e muito √∫til.</p>

<p>PHP tem v√°rias ferramentas pra lhe dar suporte a manipula√ß√£o de dados em formato bin√°rio, mas √© bom saber desde o come√ßo: se voc√™ est√° buscando efici√™ncia de ultra baixo n√≠vel, PHP n√£o √© a sua linguagem.</p>

<p>Mas continua aqui! <strong>Neste artigo eu vou te mostrar algumas coisas important√≠ssimas sobre opera√ß√µes bitwise, como lidar com bin√°rios e hexadecimais, e conhecimentos que lhe ser√£o √∫teis em QUALQUER linguagem.</strong></p>

<p>Este artigo ficou bem grandinho, ent√£o eu vou deixar aqui uma lista r√°pida pra que voc√™ possa navegar direto para as se√ß√µes que voc√™ quiser.</p>

<ul>
<li><a href="#php-melhor-linguagem">Por que PHP talvez n√£o seja a melhor linguagem pra isso?</a></li>
<li><a href="#introducao-binario-hexadecimal">Uma breve introdu√ß√£o aos formatos bin√°rio e hexadecimal</a></li>
<li><a href="#vai-um">Opera√ß√µes de "vai um" (carry)</a></li>
<li><a href="#representacao-em-memoria">Representa√ß√£o de dados na mem√≥ria do computador</a></li>
<li><a href="#overflow">Overflows Aritm√©ticos</a></li>
<li><a href="#numeros-e-strings-binarias-no-php">N√∫meros e strings bin√°rias no PHP</a></li>
<li><a href="#int-ou-string">Bin√°rios: Inteiros ou Strings, qual usar no PHP?</a></li>
<li><a href="#depurando-binarios-em-php">Depurando valores bin√°rios em PHP</a></li>
<li><a href="#visualizando-strings-binarias">Visualizando strings bin√°rias</a></li>
<li><a href="#operacoes-bitwise">Opera√ß√µes Bin√°rias (Bitwise)</a></li>
<li><a href="#o-que-e-bitmask">O que √© uma M√°scara? (bitmask)</a></li>
<li><a href="#corrigindo-inteiros">Corrigindo Inteiros</a></li>
<li><a href="#conclusao">Conclus√£o</a></li>
</ul>

<h2 id="php-melhor-linguagem">Por que PHP talvez n√£o seja a melhor linguagem pra isso?</h2>

<p>Veja bem, eu amo PHP, t√°? N√£o me leve a mal. E eu tenho certeza de que PHP √© capaz de lidar com muito mais casos do que voc√™ possa imaginar. Mas se voc√™ precisa ser extremamente eficiente quando lidar com bin√°rios, o PHP n√£o vai segurar a barra.</p>

<p>Clarificando: eu n√£o t√¥ falando de uma aplica√ß√£o que possa consumir 5 ou 10mb a mais. Eu estou falando sobre alocar o montante exato necess√°rio pra determinado tipo de dado.</p>

<p>De acordo com a <a href="https://www.php.net/manual/pt_BR/language.types.integer.php">documenta√ß√£o oficial sobre o tipo integer</a>, PHP representa n√∫meros decimais, hexadecimais, octais e bin√°rios com o tipo <em>integer</em>. Ent√£o n√£o importa muito o valor que voc√™ coloque numa vari√°vel deste tipo, ela ser√° sempre um <em>integer</em>.</p>

<p>Voc√™ provavelmente j√° ouviu falar do ZVAL antes, aquela <em>struct</em> em C que representa toda vari√°vel PHP. Esta <em>struct</em> tem <a href="https://github.com/php/php-src/blob/da0663a337b608a4b0008672b494e3a71e6e4cfc/Zend/zend_types.h#L286">um campo para representar todos os integers chamado zend_long</a>. Como voc√™ pode ver, <em>zend&#95;long</em> √© do tipo <em>lval</em>, cujo tamanho depende da plataforma (32 ou 64 bits): numa plataforma 64 bits, <a href="https://github.com/php/php-src/blob/74f3bfc6eb7ec80287178e46bd5c269fd371ce5a/Zend/zend_long.h#L30-L31">ser√° um integer de 64 bits</a>, enquanto numa plataforma 32 bits, <a href="https://github.com/php/php-src/blob/74f3bfc6eb7ec80287178e46bd5c269fd371ce5a/Zend/zend_long.h#L40-L41">ser√° um integer de 32 bits</a>.</p>

<pre><code># zval guarda todo integer como lval
typedef union _zend_value {
  zend_long lval;
  // ...
} zend_value;

# lval √© um integer 32 ou 64-bit
#ifdef ZEND_ENABLE_ZVAL_LONG64
 typedef int64_t zend_long;
 // ...
#else
 typedef int32_t zend_long;
 // ...
#endif
</code></pre>

<p>Em suma: n√£o importa se voc√™ precisa guardar os valores <em>0xff</em>, <em>0xffff</em>, <em>0xffffff</em> ou o que for. Todos ser√£o armazenados como um long (<em>lval</em>) com 32 ou 64 bits no PHP.</p>

<p>Eu recentemente trabalhei na emula√ß√£o de um microcontrolador e, ao mesmo tempo que tratar a mem√≥ria e opera√ß√µes corretamente √© essencial, eu n√£o me importei tanto com a efici√™ncia na aloca√ß√£o de mem√≥ria porque o meu computador consegue compensar isto em ordens de grandeza.</p>

<p>√â claro que tudo muda quando voc√™ fala sobre extens√µes em C ou FFI, mas n√£o √© disso que eu t√¥ falando. Eu t√¥ falando de PHP puro! (PHP das ruas como diria o grande Pok√©m√£oBR xD)</p>

<p>Ent√£o lembre-se: trabalhar dados bin√°rios em PHP funciona e voc√™ consegue desenvolver qualquer aplica√ß√£o que quiser, mas os tipos n√£o v√£o encaixar de forma eficiente na maioria das vezes.</p>

<h2 id="introducao-binario-hexadecimal">Uma breve introdu√ß√£o aos formatos bin√°rio e hexadecimal</h2>

<p>Bom, antes de a gente falar sobre como o PHP trabalha com dados bin√°rios, a gente precisa parar um pouquinho e falar sobre bin√°rios antes. Se voc√™ acha que j√° sabe tudo o que precisa sobre bin√°rios, pode <a href="#numeros-e-strings-binarias-no-php">pular direto para a se√ß√£o "N√∫meros e Strings bin√°rias no PHP"</a>.</p>

<p>Existe um neg√≥cio na matem√°tica chamado "base". A base define como n√≥s podemos representar quantidades em diferentes formatos. N√≥s, humanos, normalmente utilizamos a base decimal (base 10) que nos permite representar n√∫meros somente com os d√≠gitos 0, 1, 2, 3, 4, 5, 6, 7, 8 e 9.</p>

<p>Pra deixar nossos exemplos mais simples eu vou chamar o n√∫mero "20" de "20 decimal".</p>

<p>N√∫meros bin√°rios (base 2) podem representar qualquer n√∫mero, mas apenas utilizando dois d√≠gitos: 0 e 1.
O 20 decimal pode ser representado em bin√°rio como 0b000<strong>10100</strong>. N√£o se preocupe em converter este n√∫mero, deixa que o computador faz isso pra ti üòâ</p>

<p>N√∫meros hexadecimais (base 16) podem representar qualquer n√∫mero e utilizam n√£o somente os dez d√≠gitos que vimos na base 10 (0, 1, 2, 3, 4, 5, 6, 7, 8 e 9) mas tamb√©m seis caracteres do alfabeto latino: a, b, c, d, e, e o caractere f.</p>

<p>O 20 decimal pode ser representado como 0x<strong>14</strong> em hexadecimal. De novo, n√£o tente converter na sua cabe√ßa: deixa que os computadores s√£o especialistas nisso!</p>

<p><strong>O que √© importante voc√™ entender √© que n√∫meros podem ser representados em diferentes bases:</strong> bin√°ria (base 2), octal (base 8), decimal (base 10, a nossa base comum) e hexadecimal (base 16).</p>

<p>Em PHP e diversas linguagens, <strong>n√∫meros bin√°rios</strong> s√£o escritos normalmente mas com um <strong>prefixo 0b</strong>, como o 20 decimal foi representado assim: <strong>0b</strong>00010100. <strong>N√∫meros hexadecimais</strong> recebem um <strong>prefixo 0x</strong>, como o 20 decimal que foi representado assim: <strong>0x</strong>14.</p>

<p>Voc√™ j√° deve ter ouvido falar: computadores n√£o guardam dados da forma como n√≥s entendemos. Tudo √© representado utilizando n√∫meros bin√°rios: zeros e uns (0 e 1). Caracteres, n√∫meros, s√≠mbolos, instru√ß√µes... tudo √© representado usando base 2. Caracteres s√£o somente uma conven√ß√£o de n√∫meros em sequ√™ncia: o caractere ‚Äòa‚Äô, por exemplo, √© o n√∫mero 97 na tabela ASCII.</p>

<p>Mesmo com tudo guardado em formato bin√°rio, a forma mais conveniente para programadores(as) lerem estes valores √© utilizando hexadecimais. Tipo... a gente l√™ eles como se fosse poema, se liga:</p>

<pre><code># string "abc"
‚Äòabc‚Äô

# formato bin√°rio
0b01100001 0b01100010 0b01100011

# formato hexadecimal &lt;3
0x61 0x62 0x63
</code></pre>

<p>Enquanto os bin√°rios tomam um espa√ßo visual enorme, hexadecimais s√£o bem arrumadinhos. √â por este motivo que normalmente utilizamos hexadecimais quando lidamos com programa√ß√£o de baixo n√≠vel.</p>

<h2 id="vai-um">Opera√ß√µes de "vai um" (carry)</h2>

<p>Voc√™ j√° conhece o conceito de "vai um", mas eu preciso que voc√™ preste aten√ß√£o nele para que possamos utilizar diferentes bases.</p>

<p>Na base decimal n√≥s conseguimos representar n√∫meros utilizando apenas dez d√≠gitos, do zero (0) ao nove (9). Mas sempre que voc√™ tentar representar qualquer n√∫mero maior que 9 n√≥s n√£o temos mais d√≠gitos dispon√≠veis! Ent√£o o que a gente precisa fazer √© adicionar um prefixo com o d√≠gito um (1) e devolver o d√≠gito √† direita para zero (0).</p>

<pre><code># decimal (base 10)
1 + 1 = 2
2 + 2 = 4
9 + 1 = 10 // &lt;- vai um
</code></pre>

<p>Na base bin√°ria temos o mesmo comportamento, mas limitados aos d√≠gitos 0 e 1.</p>

<pre><code># bin√°rio (base 2)
0 + 0  = 0
0 + 1  = 1
1 + 1  = 10 // &lt;- vai um
1 + 10 = 11
</code></pre>

<p>E a mesma coisa acontece com a base hexadecimal, mas com uma faixa mais ampla.</p>

<pre><code># hexadecimal (base 16)
1 + 9  = a // sem vai um
1 + a  = b
1 + f  = 10 // &lt;- vai um
1 + 10 = 11
</code></pre>

<p>Como voc√™ percebeu, opera√ß√µes "vai um" precisam de mais d√≠gitos para representar um certo n√∫mero. Compreender isto te permite entender como alguns tipos de dados s√£o limitados e, por serem armazenados em computadores, essa limita√ß√£o √© representada no formato bin√°rio.</p>

<h2 id="representacao-em-memoria">Representa√ß√£o de dados na mem√≥ria do computador</h2>

<p>Como eu comentei antes, computadores armazenam tudo usando o formato bin√°rio. Ent√£o apenas 0s e 1s s√£o efetivamente armazenados.</p>

<p>The easiest way to visualize how they are stored, is by imagining a big table with a single row and many columns (as many as storage capacity), where each column is a binary digit (bit).</p>

<p>A forma mais f√°cil de visualizar como estes dados s√£o armazenados √© imaginar uma grande tabela com uma √∫nica linha e v√°rias colunas (tantas colunas quanto a capacidade de armazenamento), onde cada coluna representa um d√≠gito bin√°rio (um bit).</p>

<p>A gente pode representar o nosso 20 decimal nesta tabela utilizando apenas 8 bits, fica assim:</p>

<table><tbody>
<tr>
  <th>Posi√ß√£o (Endere√ßo)</th>
  <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
</tr>
<tr>
  <th>Bit</th>
  <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td>
</tr>
</tbody></table>

<p>Um inteiro de 8 bits sem sinal (unsigned integer de 8 bits) √© um n√∫mero inteiro que pode ser representado somente com no m√°ximo 8 d√≠gitos bin√°rios. Ent√£o <strong>0b11111111</strong> (255 decimal) √© o maior n√∫mero que este integer pode armazenar. Somar 1 ao 255 decimal requer uma opera√ß√£o "vai um", que n√£o pode ser representada com a mesma quantidade de d√≠gitos (precisaria de 9 d√≠gitos, no nosso caso).</p>

<p>Com isto em mente n√≥s podemos facilmente entender o motivo de existir tantas formas de representar n√∫meros e o que elas realmente s√£o: uint8 √© um inteiro de 8 bits sem sinal (0 a 255 decimal), uint16 √© um inteiro de 16 bits sem sinal (0 a 65.535 decimal). Existe tamb√©m uint32, uint64 e teoricamente limites maiores.</p>

<p>Inteiros com sinal, que tamb√©m podem representar valores negativos, normalmente usam o √∫ltimo bit para determinar se o valor √© positivo (√∫ltimo bit = 0) ou negativo (√∫ltimo bit = 1). Como voc√™ provavelmente deduziu, um inteiro com sinal √© capaz de representar n√∫meros bem menores que os inteiros sem sinal. Um inteiro com sinal de 8 bits √© capaz de representar do decimal -128 at√© o decimal 127 apenas.</p>

<p>Aqui vai o decimal -20, representado como um inteiro de 8 bits e com sinal. Note como o √∫ltimo bit (endere√ßo 0) est√° ligado (o valor √© igual a 1). Este bit marca o n√∫mero todo como negativo.</p>

<table><tbody>
<tr>
  <th>Posi√ß√£o (Endere√ßo)</th>
  <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
</tr>
<tr>
  <th>Bit</th>
  <td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td>
</tr>
</tbody></table>

<p>Eu espero que at√© aqui tudo tenha feito sentido. Essa introdu√ß√£o √© muito importante pra que voc√™ entenda como os computadores funcionam internamente. S√≥ a partir da√≠ voc√™ vai conseguir entender de forma confort√°vel o que o PHP est√° fazendo por debaixo dos panos.</p>

<h2 id="overflow">Overflows Aritm√©ticos</h2>

<p><strong>Nota sobre a palavra Overflow:</strong> a tradu√ß√£o de Overflow seria "transbordo", mas este termo √© pouco utilizado. Eu vou me manter utilizando o termo em ingl√™s: Overflow. O significado √© equivalente ao de "transbordar" mesmo. Quando voc√™ enche um copo d‚Äô√°gua al√©m do limite, parte da √°gua sai do copo: isto √© um transbordo ou overflow.</p>

<p>A forma como os n√∫meros s√£o representados (8 bits, 16 bits...) determina a faixa de valores m√≠nimos e m√°ximos que podem ser representados. E isto ocorre por conta da forma como eles s√£o armazenados em mem√≥ria: adicionar 1 a um d√≠gito bin√°rio 1 deveria causar uma opera√ß√£o "vai um" (carry) e, portanto, um outro bit seria necess√°rio para fazer prefixo ao n√∫mero atual.</p>

<p>J√° que os n√∫meros inteiros s√£o bem definidinhos, n√£o √© poss√≠vel confiar em opera√ß√µes "vai um" que ultrapassam seu limite. (Na verdade √â POSS√çVEL, mas n√£o recomendo nem para meu pior inimigo)</p>

<p>Vamos usar o tipo uint8 (inteiro de 8 bits sem sinal) como exemplo e representar seu n√∫mero m√°ximo - 1: o decimal 254.</p>

<table><tbody>
<tr>
  <th>Posi√ß√£o (Endere√ßo)</th>
  <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
</tr>
<tr>
  <th>Bit</th>
  <td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td>
</tr>
</tbody></table>

<p>Aqui n√≥s estamos bem perto do limite dos 8 bits (decimal 255). Se somarmos 1 a este n√∫mero teremos o decimal 255 e a seguinte representa√ß√£o:</p>

<table><tbody>
<tr>
  <th>Posi√ß√£o (Endere√ßo)</th>
  <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
</tr>
<tr>
  <th>Bit</th>
  <td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td>
</tr>
</tbody></table>

<p>Todos os bits est√£o ligados! Somar 1 a este n√∫mero requer uma opera√ß√£o de "vai um" que n√£o pode acontecer, porque n√£o temos bits o suficiente: todos os 8 bits est√£o ligados! Isto gera uma coisa chamada <strong>overflow</strong>, que acontece toda vez que voc√™ tenta ir acima de um determinado limite. A opera√ß√£o bin√°ria 255 + 2 vai resultar em 1, e fica representada assim:</p>

<table><tbody>
<tr>
  <th>Posi√ß√£o (Endere√ßo)</th>
  <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
</tr>
<tr>
  <th>Bit</th>
  <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td>
</tr>
</tbody></table>

<p>Este comportamento n√£o √© aleat√≥rio! Existe toda uma base de c√°lculos, que n√£o √© relevante aqui, envolvida para determinar este valor.</p>

<h2 id="numeros-e-strings-binarias-no-php">N√∫meros e strings bin√°rias no PHP</h2>

<p>Ok, de volta ao PHP! Foi mal desviar tanto o assunto, mas foi necess√°rio.</p>

<p>Eu espero que a partir deste momento os pontos j√° foram ligados na sua cabe√ßa: n√∫meros bin√°rios, como eles s√£o armazenados, o que √© um overflow, como o PHP representa n√∫meros...</p>

<p>O decimal 20 representado como um inteiro no PHP pode ter dois formatos diferentes, dependendo da sua plataforma. A plataforma x86 o representa com 32 bits enquanto a plataforma x64 o representa com 64 bits, ambos com sinal (permite valores negativos). N√≥s bem sabemos que o decimal 20 pode ser representado num espa√ßo bem mais curto, de 8 bits apenas, mas o PHP trata todo valor decimal como um inteiro de 32 ou 64 bits.</p>

<p>No PHP tamb√©m existe o conceito de strings bin√°rias, que podem ser convertidas e interpretadas utilizando as fun√ß√µes <a href="https://www.php.net/manual/en/function.pack.php">pack()</a> and <a href="https://www.php.net/manual/en/function.unpack.php">unpack()</a>.</p>

<p>A maior diferen√ßa entre strings bin√°rias e n√∫meros no PHP √© que strings bin√°rias apenas armazenam dados, como um buffer. J√° os inteiros no PHP (bin√°rios ou n√£o) nos permite executar opera√ß√µes aritm√©ticas neles como a soma, subtra√ß√£o e opera√ß√µes bin√°rias (bitwise) como AND, OR e XOR.</p>

<h2 id="int-ou-string">Bin√°rios: Inteiros ou Strings, qual usar no PHP?</h2>

<p>Para transportar dados n√≥s normalmente utilizamos strings bin√°rias. Ent√£o ler um arquivo bin√°rio ou se comunicar por rede vai nos exigir utilizar as fun√ß√µes <em>pack()</em> e <em>unpack()</em> em strings bin√°rias.</p>

<p>Opera√ß√µes como OR e XOR n√£o s√£o confi√°veis quando executadas com strings, ent√£o n√≥s devemos utiliz√°-las com inteiros.</p>

<h2 id="depurando-binarios-em-php">Depurando valores bin√°rios em PHP</h2>

<p>Agora vem a parte legal! Vamos sujar as m√£os e brincar um pouco com c√≥digo PHP!
A primeira coisa que eu quero te mostrar √© como visualizar os dados. Afinal a gente precisa entender o que estamos lidando.</p>

<h3>Visualizando representa√ß√µes bin√°rias de n√∫meros inteiros</h3>

<p>Depurar inteiros √© bem simples: a gente pode usar a fun√ß√£o <a href="https://www.php.net/manual/en/function.sprintf">sprintf()</a>. A sua formata√ß√£o √© muito poderosa e nos permite identificar rapidamente o que os valores s√£o.</p>

<p>Abaixo eu vou representar o decimal 20 como um inteiro de 8 bits em bin√°rio e como um byte hexadecimal.</p>

<pre><code>&lt;?php
// Decimal 20
$n = 20;

echo sprintf(‚Äò%08b‚Äò, $n) . "\n";
echo sprintf(‚Äò%02X‚Äô, $n) . "\n";

// Sa√≠da:
00010100
14
</code></pre>

<p>O formato "%08b" apresenta a vari√°vel $n no formato bin√°rio (b) utilizando 8 d√≠gitos (08).</p>

<p>O formato "%02X" representa a vari√°vel $n no formato hexadecimal (X) e utilizando 2 d√≠gitos (02).</p>

<h3 id="visualizando-strings-binarias">Visualizando strings bin√°rias</h3>

<p>Enquanto os inteiros no PHP s√£o sempre de 32 ou 64 bits, uma string pode ocupar tanta mem√≥ria quanto seu conte√∫do requer. Para visualizar seu valor n√≥s precisamos interpretar cada byte.</p>

<p>A nossa sorte √© que no PHP strings podem ter seus caracteres acessados como fazemos com arrays, ent√£o cada posi√ß√£o da string aponta para um char de 1 byte. Abaixo mostro um exemplo de como estes caracteres podem ser acessados:</p>

<pre><code>&lt;?php
$str = ‚Äòthephp.website‚Äô;

echo $str[3];
echo $str[4];
echo $str[5];

// sa√≠da:
php
</code></pre>

<p>Confiando que cada char tem 1 byte, podemos facilmente chamar a fun√ß√£o <a href="https://www.php.net/manual/en/function.ord">ord()</a> para converter este char em um inteiro de 1 byte (8 bits). Mais ou menos assim:</p>

<pre><code>&lt;?php
$str = ‚Äòthephp.website‚Äô;

$p = ord($str[3]);
$s = ord($str[4]);
$t = ord($str[5]);

echo sprintf(‚Äò%02X %02X %02X‚Äô, $p, $s, $t);
// Sa√≠da:
70 68 70
</code></pre>

<p>A gente pode ver que n√£o estamos nos confundindo ao verificar este mesmo valor utilizando a ferramenta hexdump:</p>

<pre><code>$ echo ‚Äòphp‚Äô | hexdump
// Sa√≠da
0000000 70 68 70 ...
</code></pre>

<p>A primeira coluna mostra o endere√ßo apenas, e a partir da segunda coluna n√≥s vemos os valores hexadecimais representando os caracteres ‚Äòp‚Äô, ‚Äòh‚Äô e ‚Äòp‚Äô.</p>

<p>N√≥s tamb√©m podemos utilizar as fun√ß√µes <a href="https://www.php.net/manual/en/function.pack.php">pack()</a> e <a href="https://www.php.net/manual/en/function.unpack.php">unpack()</a> quando lidamos com strings bin√°rias e eu tenho um √≥timo exemplo pra voc√™ bem aqui!!</p>

<p>Digamos que voc√™ queira ler um arquivo JPEG para coletar alguns metadados (como o EXIF, por exemplo). A gente pode abrir o arquivo utilizando o modo de leitura bin√°rio. Vamos fazer isto imediatamente e ler os primeiros 2 bytes:</p>

<pre><code>&lt;?php

$h = fopen(arquivo.jpeg‚Äô, ‚Äòrb‚Äô);

// Ler 2 bytes
$soi = fread($h, 2);
</code></pre>

<p>Para coletar estes valores num array de n√∫meros inteiros a gente pode usar a fun√ß√£o unpack desta forma:</p>

<pre><code>$ints = unpack(‚ÄòC*‚Äô, $soi);

var_dump($ints);
// Sa√≠da
array(2) {
  [1] =&gt; int(-1)
  [2] =&gt; int(-40)
}

echo sprintf(‚Äò%02X‚Äô, $ints[1]);
echo sprintf(‚Äò%02X‚Äô, $ints[2]);
// Sa√≠da
FFD8
</code></pre>

<p>Note que o formato "C" que passamos para a fun√ß√£o unpack() vai interpretar caracteres na string $soi como n√∫meros inteiros de 8 bit sem sinal. O modificador "*" faz com que o unpack() extraia todos os caracteres restantes na string da mesma forma.</p>

<h2 id="operacoes-bitwise">Opera√ß√µes Bin√°rias (Bitwise)</h2>

<p>O PHP implementa todas as opera√ß√µes bin√°rias que voc√™ possa querer. Elas s√£o implementadas como express√µes e seus resultados s√£o descritos abaixo:</p>

<table>
<thead>
  <th>C√≥digo PHP</th><th>Nome</th><th>Descri√ß√£o</th>
</thead>
<tbody>
  <tr>
    <td>$x | $y</td><td>Ou inclusivo (Or)</td><td>Um valor com os bits ligados em $x e $y ao mesmo tempo</td>
  </tr>
  <tr>
    <td>$x ^ $y</td><td>Ou exclusivo (Or)</td><td>Um valor com os bits ligados em $x ou $y, mas nunca nos dois ao mesmo tempo</td>
  </tr>
  <tr>
    <td>$x & $y</td><td>E (AND)</td><td>Um valor somente com os bits ligados em $x e $y ao mesmo tempo</td>
  </tr>
  <tr>
    <td>~$x</td><td>Negar (Not)</td><td>Nega todos os bits em $x. O que √© 1 vira 0, e o que √© 0 vira 1</td>
  </tr>
  <tr>
    <td>$x << $y</td><td>Deslocamento a esquerda (Left shift)</td><td>Desloca os bits de $x para a esquerda $y vezes</td>
  </tr>
  <tr>
    <td>$x >> $y</td><td>Deslocamento a direita (Right shift)</td><td>Desloca os bits de $x para a direita $y vezes</td>
  </tr>
</tbody>
</table>

<p>Eu vou explicar uma por uma como estas opera√ß√µes funcionam, n√£o se preocupe!
Vamos assumir que <em>$x = 0x20</em> e <em>$y = 0x30</em>. Os exemplos abaixo v√£o os apresentar usando a nota√ß√£o bin√°ria para esclarecer as coisas.</p>

<h3>Como o Ou Inclusivo (Or) funciona ($x | $y)</h3>

<p>A opera√ß√£o Ou inclusivo vai produzir um resultado que pega todos os bits ligados das duas vari√°veis passadas. Ent√£o a opera√ß√£o $x | $y deve retornar o valor 0x30. Veja o que t√° acontecendo abaixo:</p>

<pre><code>// 1 | 1 = 1
// 1 | 0 = 1
// 0 | 0 = 0

0b00100000 // $x = 0x20
0b00110000 // $y = 0x30
OR ------- // $x | $y
0b00110000 // 0x30
</code></pre>

<p>Repare bem: da esquerda para a direita, o sexto bit de $x  estava ligado (valor = 1) enquanto os bits 5 e 6 de $y tamb√©m estavam ligados. O resultado une os dois e gera um valor com os bits 5 e 6 ligados: 0x30.</p>

<h3>Como o Ou exclusivo (Xor) funciona ($x ^ $y)</h3>

<p>O Ou exclusivo (tamb√©m conhecido como Xor) captura bits que estejam ligados em apenas um dos lados da opera√ß√£o. Ent√£o o resultado de $x ^ $y √© 0x10. Veja o que acontece nesta opera√ß√£o:</p>

<pre><code>// 1 ^ 1 = 0
// 1 ^ 0 = 1
// 0 ^ 0 = 0

0b00100000 // $x = 0x20
0b00110000 // $y = 0x30
XOR ------ // $x ^ $y
0b00010000 // 0x10
</code></pre>

<h3>Como o E (And) funciona ($x &amp; $y)</h3>

<p>A opera√ß√£o E √© bem mais simples de entender. Cada bit, dos dois lados, s√£o comparados e apenas os valores que s√£o iguais ser√£o coletados para o resultado.</p>

<p>O resultado de $x &amp; $y √© 0x20, olha o porqu√™:</p>

<pre><code>// 1 &amp; 1 = 1
// 1 &amp; 0 = 0
// 0 &amp; 0 = 0

0b00100000 // $x = 0x20
0b00110000 // $y = 0x30
AND ------ // $x &amp; $y
0b00100000 // 0x20
</code></pre>

<h3>Como a opera√ß√£o Negar (Not) funciona (~$x)</h3>

<p>A opera√ß√£o Negar requer apenas um operando e simplesmente inverte todos os bits. Ela transforma todos bits que eram 0 em 1, e todos os bits que eram 1 em 0. Veja:</p>

<pre><code>// ~1 = 0
// ~0 = 1

0b00100000 // $x = 0x20
NOT ------ // ~$x
0b11011111 // 0xDF
</code></pre>

<p>Se voc√™ rodou esta opera√ß√£o no PHP e decidiu depurar o resultado utilizando sprintf() voc√™ provavelmente recebeu um n√∫mero bem mais longo, n√©? Eu vou te explicar o que aconteceu e como corrigir abaixo na se√ß√£o <a href="#corrigindo-inteiros">"Corrigindo Inteiros"</a>.
Deslocamentos √† esquerda e √† direita (Left e Right shifts) ($x &lt;&lt; $n, $x >> $n)
Deslocar bits √© a mesma coisa que multiplicar ou dividir seus n√∫meros por m√∫ltiplos de dois. O que esta opera√ß√£o faz √© que todos os bits andem $n vezes para a esquerda ou direita.</p>

<p>Eu vou pegar um n√∫mero bin√°rio menor para representar esta opera√ß√£o, s√≥ pra deixar a leitura mais facilitada. Vamos pegar $x = 0b0010 como exemplo! Se a deslocarmos uma vez para a esquerda, aquele bit 1 se move um passo para a esquerda:</p>

<pre><code>0b0010 // $x
$x = $x &lt;&lt; 1
0b0100
</code></pre>

<p>A mesma coisa acontece com o deslocamento a direita. Agora que $x = 0b0100 vamos desloc√°-la para a direita duas vezes:</p>

<pre><code>0b0100 // $x
$x = $x &gt;&gt; 2
0b0001
</code></pre>

<p>No fim das contas, deslocar um n√∫mero $n vezes para a esquerda √© o mesmo que multiplic√°-lo por 2 $n vezes, e desloc√°-lo $n vezes para a direita √© equivalente a dividir por 2 $n vezes.</p>

<h2 id="o-que-e-bitmask">O que √© uma M√°scara? (bitmask)</h2>

<p>Tem v√°rias coisas interessantes que a gente pode fazer com estas opera√ß√µes e outras t√©cnicas. Uma √≥tima t√©cnica para sempre trazer consigo √© utilizar m√°scaras (bitmasks).</p>

<p>Uma m√°scara √© apenas um bin√°rio que voc√™ escolhe, escrito para extrair uma informa√ß√£o espec√≠fica de acordo com a sua necessidade.</p>

<p>Por exemplo, vamos tomar a ideia de que um inteiro de 8 bits com sinal √© positivo quando o √∫ltimo bit est√° desligado (valor = 0) e √© negativo quando o √∫ltimo bit est√° ligado (valor = 1). Eu ent√£o te pergunto: o n√∫mero 0x20 √© positivo ou negativo? E o 0x81?</p>

<p>Pra responder essas perguntas n√≥s podemos criar um byte que liga apenas o √∫ltimo bit (0b10000000, equivalente a 0x80) e utilizar a opera√ß√£o E (AND) entre este valor e 0x20. Se o resultado for 0x80 (0b10000000, a nossa m√°scara) ent√£o o n√∫mero √© negativo, se n√£o o n√∫mero √© positivo:</p>

<pre><code>// 0x80 === 0b10000000 (bitmask)
// 0x20 === 0b00100000
// 0x81 === 0b10000001

0x20 &amp; 0x80 === 0x80 // false
0x81 &amp; 0x80 === 0x80 // true
</code></pre>

<p>Isto √© muito √∫til quando voc√™ quer lidar com flags. Voc√™ pode inclusive ver exemplos de utiliza√ß√£o no pr√≥prio PHP: <a href="https://www.php.net/manual/pt_BR/function.error-reporting.php">the error reporting flags</a>.</p>

<p>√â poss√≠vel escolher quais tipos de s√£o reportados fazendo algo assim:</p>

<pre><code>error_reporting(E_WARNING | E_NOTICE);
</code></pre>

<p>O que t√° acontecendo aqui? Bom, vamos verificar os valores que utilizamos:</p>

<pre><code>0b00000010 (0x02) E_WARNING
0b00001000 (0x08) E_NOTICE
OR -------
0b00001010 (0x0A)
</code></pre>

<p>Ent√£o sempre que o PHP ver que um Notice poderia ser reportado, vai verificar algo assim:</p>

<pre><code>// error reporting que definimos antes
$e_level = 0x0A;

// Pode lan√ßar um notice?
if ($e_level &amp; E_NOTICE === E_NOTICE)
   // Lan√ßar notice
</code></pre>

<p>E voc√™ vai ver isto em tudo quanto √© lugar! Arquivos bin√°rios, processadores e todo tipo de computa√ß√£o de baixo n√≠vel!</p>

<h2 id="corrigindo-inteiros">Corrigindo Inteiros</h2>

<p>No PHP tem algo muito particular quando lidamos com n√∫meros bin√°rios: nossos inteiros s√£o de 32 ou 64 bits. Isto significa que v√°rias vezes vamos precisar corrigir os valores para confiar em nossos c√°lculos.</p>

<p>Por exemplo, a seguinte opera√ß√£o numa m√°quina de 64 bits vai nos retornar um n√∫mero bem estranho (apesar de ser o resultado correto):</p>

<pre><code>echo sprintf(
  ‚Äò0b%08b‚Äô,
  ~0x20
);

// Expectativa
0b11011111
// Realidade
0b1111111111111111111111111111111111111111111111111111111111011111
</code></pre>

<p>Diab√© isso!? Veja, ao negar aquele inteiro 0x20 n√≥s transformamos todos os bits zero e os transformamos em 1s. Adivinha o que costumava ser zero? Exato, todos os outros 56 bits √† esquerda que n√≥s ignoramos antes!</p>

<p>Novamente, isto acontece porque os inteiros do PHP t√™m 32 ou 64 bits, n√£o importa o valor que voc√™ colocar dentro deles!</p>

<p>Mas o c√≥digo ainda funciona como esperado. Por exemplo, a opera√ß√£o <code>~0x20 &amp; 0b11011111 === 0b11011111</code> resulta em <em>bool(true)</em>. Mas tenha sempre em mente que estes bits √† esquerda est√£o ali, ou voc√™ pode acabar tendo comportamentos inesperados no seu c√≥digo.</p>

<p>Para resolver este problema, voc√™ pode corrigir os inteiros aplicando uma m√°scara (bitmask) que limita os zeros. Por exemplo, para normalizar ~0x20 como um inteiro de 8 bits a gente precisa utilizar uma opera√ß√£o E (AND) com o 0xFF (0b11111111) de forma que todos os 56 bits restantes v√£o ser desligados (valor = 0).</p>

<pre><code>~0x20 &amp; 0xFF
-&gt; 0b11011111
</code></pre>

<p><strong>Presten√ß√£o ein!</strong> Nunca se esque√ßa de o que voc√™ est√° armazenando em suas vari√°veis, ou sua aplica√ß√£o pode acabar com bugs bem dif√≠ceis de se encontrar. Por exemplo, vamos ver o que acontece quando deslocamos √† direita o valor acima sem utilizar uma m√°scara.</p>

<pre><code>~0x20 &amp; 0xFF
-&gt; 0b11011111

0b11011111 &gt;&gt; 2
-&gt; 0b00110111 // esperado

(~0x20 &amp; 0xFF) &gt;&gt; 2
-&gt; 0b00110111 // esperado

(~0x20 &gt;&gt; 2) &amp; 0xFF
-&gt; 0b11110111 // esperado?
</code></pre>

<p>S√≥ para esclarecer: do ponto de vista do PHP este comportamento √â esperado, porque voc√™ claramente est√° lidando com um inteiro de 64 bits aqui! Voc√™ precisa sempre deixar bem expl√≠cito o que o SEU programa precisa.</p>

<p><strong>Dica de mestre:</strong> voc√™ pode escapar de erros bestas como estes ao <a href="https://thephp.website/br/edicao/tdd-com-php-na-vida-real/">escrever seu c√≥digo com TDD</a>.</p>

<h2 id="conclusao">Enfim, bin√°rio √© maneir√£o</h2>

<p>Eu espero que voc√™ tenha curtido ler tanto quanto eu curti escrever este post. E mais importante: eu espero que este conhecimento te permita se aventurar por este maravilhoso mundo de dados bin√°rios.</p>

<p>Com estas ferramentas em m√£o, todo o resto √© apenas quest√£o de achar a documenta√ß√£o correta sobre como arquivos ou protocolos bin√°rios se comportam. Tudo √© uma sequ√™ncia de bin√°rios no fim das contas.</p>

<p>Eu recomendo fortemente que voc√™ d√™ uma olhada na especifica√ß√£o dos formatos PDF ou EXIF (metadados de imagem). Talvez voc√™ at√© queira brincar com a sua pr√≥pria implementa√ß√£o do <a href="https://thephp.website/en/issue/messagepack-vs-json-benchmark/">formato de serializa√ß√£o MessagePack</a> ou talvez Avro, Protobuf... Infinitas possibilidades!</p>

<p>Como voc√™ deve ter reparado este arquivo me levou um temp√£o pra escrever. Se voc√™ quiser recompensar o esfor√ßo, d√° aquela compartilhada e salva nos favoritos pra voltar aqui sempre que tiver alguma d√∫vida sobre este t√≥pico.</p>

<p>Talvez em breve eu volte com algumas coisas mais pr√°ticas sobre lidar com bin√°rios! :)</p>

<p>Valeu!</p>

<div class="align-right">
  --
  <a href="https://twitter.com/nawarian" rel="nofollow">
    @nawarian
  </a>
</div>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "Opera√ß√µes bin√°rias (bitwise) com PHP",
  "description": "Recentemente eu trabalhei em diferentes projetos que me for√ßaram a usar bastante opera√ß√µes com bin√°rios em PHP. De ler arquivos a emular processadores, este √© um conhecimento interessant√≠ssimo e muito √∫til.",
  "image": [
    "https://thephp.website/assets/images/posts/20-bitwise-php/cover-640.webp"
   ],
  "datePublished": "2021-02-24T00:00:00+08:00",
  "dateModified": "2021-02-24T00:00:00+08:00",
  "author": {
    "@type": "Person",
    "name": "Nawarian N√≠ckolas Da Silva"
  },
   "publisher": {
    "@type": "Organization",
    "name": "ThePHP Website",
    "logo": {
      "@type": "ImageObject",
      "url": "https://thephp.website/favicon.ico"
    }
  }
}
</script>
  </div>
  </article>
  <aside class="container">
          <div class="recommended">
      <h3>Keep reading</h3>
      <ul class="card-list">
                  <li class="card">
            <a href="https://thephp.website/br/edicao/php-8-features/">
                              <div
                        class="card__image"
                        style="background-image: url(/assets/images/posts/19-php-features-640.webp)"
                        alt="Uma imagem com um elefante gigante e brilhante"
                ></div>
              
              <div class="card__content">
                <h4>PHP 8.0 lan√ßado: t√° com uma cara √≥tima!</h4>
                <p>PHP 8.0 trouxe v√°rias inova√ß√µes, dentre elas incr√≠veis mudan√ßas sint√°ticas, atualiza√ß√µes nas APIs e mudan√ßas fundamentais no core e, claro, v√°rias corre√ß√µes de bug. Aqui eu vou te mostrar as principais mudan√ßas √† linguagem!</p>
                <time>2020-11-26</time>
              </div>
            </a>
          </li>
                  <li class="card">
            <a href="https://thephp.website/br/edicao/tipos-em-php/">
                              <div
                        class="card__image"
                        style="background-image: url(/assets/images/posts/17-php-type-system-640.webp)"
                        alt="Uma mulher segurando um livro sobre textos cru√©is."
                ></div>
              
              <div class="card__content">
                <h4>Tudo o que voc√™ precisa (e n√£o precisa) saber sobre Tipos no PHP</h4>
                <p>Este √© o melhor guias entre todos que voc√™ encontrar√° na internet sobre como o PHP lida com seus tipos internamente.</p>
                <time>2020-07-29</time>
              </div>
            </a>
          </li>
                  <li class="card">
            <a href="https://thephp.website/br/edicao/messagepack-vs-json-benchmark/">
                              <div
                        class="card__image"
                        style="background-image: url(/assets/images/posts/11-messagepack-640.webp)"
                        alt="Uma fotografia de v√°rios chips de CPU."
                ></div>
              
              <div class="card__content">
                <h4>Comparando JSON e MessagePack</h4>
                <p>MessagePack ganha em praticamente todos os testes. Mas a diferen√ßa √© t√£o pequena que eu quase n√£o consigo ver benef√≠cios em migrar do JSON para msgpack. Mas resultados mais interessantes podem brotar com a chegada do JIT no PHP 8...</p>
                <time>2020-03-15</time>
              </div>
            </a>
          </li>
              </ul>
    </div>
    </aside>
</body>
<script src="/assets/build/js/main.js?id=543c4d6cdebf5d649037"></script>
</html>
