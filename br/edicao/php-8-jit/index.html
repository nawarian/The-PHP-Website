<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <link rel="stylesheet" href="/assets/build/css/main.css?id=4bf4cc8f94223aba404a">
  <link
    rel="alternate"
    type="application/json"
    title="[BR] thePHP Website"
    href="https://thephp.website/br/feed.json"
  />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="[BR] thePHP Website"
    href="https://thephp.website/br/feed.xml"
  />

  <title>Just In Time Compiler e o PHP 8 | thePHP Website</title>

  <meta name="description" content="O Just In Time compiler do PHP 8 foi implementado como parte da extens√£o Opcache e pretende compilar alguns Opcodes em instru√ß√µes de CPU em tempo de execu√ß√£o. Bora entender como isso funciona por baixo dos panos.">

  <meta property="og:title" content="Just In Time Compiler e o PHP 8">
  <meta property="og:description" content="O Just In Time compiler do PHP 8 foi implementado como parte da extens√£o Opcache e pretende compilar alguns Opcodes em instru√ß√µes de CPU em tempo de execu√ß√£o. Bora entender como isso funciona por baixo dos panos.">
  <meta property="og:url" content="https://thephp.website/br/edicao/php-8-jit">
  <meta property="og:image" content="https://thephp.website/assets/images/posts/10-php-8-jit-640.webp">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@nawarian">
  <meta name="twitter:title" content="Just In Time Compiler e o PHP 8">
  <meta name="twitter:description" content="O Just In Time compiler do PHP 8 foi implementado como parte da extens√£o Opcache e pretende compilar alguns Opcodes em instru√ß√µes de CPU em tempo de execu√ß√£o. Bora entender como isso funciona por baixo dos panos.">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151169766-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-151169766-2');
  </script>
</head>
<body class="yue">
  <nav class="menu">
    <input type="checkbox" id="menu-toggle" class="menu__toggle" />
    <label for="menu-toggle" class="menu__toggle-button">
      <img class="menu__toggle-button--inactive" src="/assets/images/burger-menu-icon.png" alt="Open Menu">
      <img class="menu__toggle-button--active" src="/assets/images/x-icon.png" alt="Close Menu">
    </label>
    <div class="menu__header">
      <a href="/br/">
        thePHP Website
      </a>
    </div>

    <div class="menu__container">
      <em class="menu__section-heading">
        Pages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/br/">Home</a>
        </li>
        <li class="menu__list-item">
          <a
            href="https://github.com/nawarian/The-PHP-Website/issues/new?title=[Suggested+Topic]%20&body=Please+describe+your+suggestion+/+Por+favor+descreva+sua+sugest√£o"
            rel="nofollow"
          >
            Pe√ßa um Post!
          </a>
        </li>
        <li class="menu__list-item">
          <a href="/br/sobre/">
            sobre.php
          </a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Languages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/en/">English</a>
        </li>
        <li class="menu__list-item">
          <a href="/br/">Portugu√™s</a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Notifications.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="https://thephp.website/br/feed.json">
            [BR] JSON Feed
          </a>
        </li>
        <li class="menu__list-item">
          <a href="https://thephp.website/br/feed.xml">
            [BR] Atom Feed (RSS)
          </a>
        </li>
      </ul>
    </div>
  </nav>

  <article class="container">
      <div class="article">
    <time datetime="2020-03-03">
      2020-03-03
    </time>

    <h1>Just In Time Compiler e o PHP 8</h1>
    <p><a href="/en/issue/php-8-jit/">Read in English</a></p>
<h2>TL;DR</h2>
<p>O Just In Time compiler do PHP 8 foi implementado
como parte da <a href="https://www.php.net/manual/en/book.opcache.php">extens√£o Opcache</a>
e tem como objetivo compilar Opcodes em instru√ß√µes
de m√°quina em tempo de execu√ß√£o.</p>
<p>Significa que <strong>com o JIT alguns Opcodes n√£o precisar√£o
ser interpretados pela Zend VM e estas instru√ß√µes ser√£o
executadas diretamente a n√≠vel de CPU.</strong></p>
<h2>JIT e PHP</h2>
<p>Uma das novidades mais comentadas sobre o PHP 8 √©
o Just In Time (JIT) compiler. V√°rios blogs e pessoas
da comunidade est√£o falando sobre isso e com certeza
√© um dos t√≥picos mais relevantes desta vers√£o. Por√©m
at√© o momento eu n√£o consegui achar muitos detalhes
sobre o que o JIT realmente faz.</p>
<p>Depois de pesquisar e desistir v√°rias vezes, eu decidi
verificar o c√≥digo fonte do PHP por conta. Alinhando
meu pouco conhecimento na linguagem C e toda informa√ß√£o
espalhada que encontrei at√© o momento, eu compilei esta
publica√ß√£o e espero que lhe ajude a entender o JIT melhor
tamb√©m.</p>
<p><strong>Ultra simplificando: quando o JIT funciona como esperado,
seu c√≥digo n√£o ser√° executado atrav√©s da Zend VM e sim
diretamente a n√≠vel de instru√ß√µes de CPU.</strong></p>
<p>Essa √© a ideia.</p>
<p>Mas pra entender melhor a gente precisa pensar sobre como
o PHP funciona internamente. N√£o √© muito complicado, mas
precisa de uma certa introdu√ß√£o ao assunto.</p>
<p>Eu escrevi um post com uma <a href="/br/edicao/como-php-funciona-na-verdade">vis√£o ampla sobre como o php funciona</a>
. Se voc√™ perceber que este post aqui est√° ficando denso
demais, verifique este outro e volta aqui mais tarde. As
coisas far√£o sentido mais facilmente.</p>
<h2>Como um c√≥digo PHP √© executado?</h2>
<p>Sabemos que o php √© uma linguagem interpretada. Mas o
que isso realmente quer dizer?</p>
<p>Sempre que voc√™ quiser executar um c√≥digo PHP, sendo este
um snippet ou uma aplica√ß√£o web inteira, voc√™ precisar√°
passar por um interpretador php. Os mais comumente utilizados
s√£o o PHP FPM e o interpretador de linha de comando.</p>
<p>O trabalho destes interpretadores √© bem direto: receber um
c√≥digo php, interpretar este c√≥digo e cuspir o resultado.</p>
<p>Isto normalmente acontece em toda linguagem interpretada.
Algumas podem remover alguns passos, mas a ideia geral √©
a mesma. No PHP funciona assim:</p>
<ol>
<li>
<p>O c√≥digo PHP √© lido e transformado em uma s√©rie de
palavras chave conhecidas como Tokens. Este processo
permite que o interpretador possa entender que parte de
c√≥digo est√° escrito em qual parte do programa. <strong>Este
primeiro passo √© chamado de Lexing ou Tokenizing.</strong></p>
</li>
<li>
<p>Com os tokens em m√£os, o interpretador PHP analisa
esta cole√ß√£o de tokens e tenta tomar algum sentido deles.
Como resultado uma √Årvore de Sintaxe Abstrata (Abstract
Syntax Tree, ou AST) √© gerada atrav√©s de um processo
chamado <strong>parsing</strong>.
Esta AST √© uma s√©rie de n√≥s (ou nodos) indicando quais
opera√ß√µes dever√£o ser executadas. Por exemplo, &quot;echo  1 + 1&quot;
deveria de fato significar &quot;apresente o resultado de 1 + 1&quot;
ou de forma mais realista &quot;apresente uma opera√ß√£o, a opera√ß√£o
√© 1 + 1&quot;.</p>
</li>
<li>
<p>Em posse do AST fica muito mais f√°cil entender as
opera√ß√µes e suas preced√™ncias. Transformar esta √°rvore
em algo que possa ser executado requer uma representa√ß√£o
intermedi√°ria (Intermediate Representation, IR) que em PHP
chamamos de Opcode. O processo de transformar a AST
em Opcodes √© chamada de <strong>compila√ß√£o</strong>.</p>
</li>
<li>
<p>Agora, com os Opcodes em m√£os vem a parte massa:
<strong>execu√ß√£o</strong> do c√≥digo! O PHP tem um motor chamado
Zend VM, que √© capaz de receber uma lista de Opcodes
e execut√°-la. Ap√≥s executar todos os Opcodes, a Zend VM
encerra a execu√ß√£o e o programa √© terminado.</p>
</li>
</ol>
<p>Eu montei um diagrama de fluxo pra tentar deixar
um pouco mais claro pra ti:</p>
<figure style="text-align: center">
  <a href="/assets/images/posts/10-php-8-jit/zendvm-no-opcache.png" target="_blank">
    <img src="/assets/images/posts/10-php-8-jit/zendvm-no-opcache.png" alt="Fluxo de interpreta√ß√£o do PHP.">
  </a>
  <figcaption>Uma vis√£o simplificada sobre como o PHP √© interpretado.</figcaption>
</figure>
<p>Diret√£o, como tu pode reparar. Mas tem um gargalo aqui:
pra qu√™ fazer o lexing e parsing do c√≥digo a cada vez
que formos executar um script se o pr√≥prio c√≥digo PHP
n√£o muda com frequ√™ncia?</p>
<p>No fim das contas a gente s√≥ se importa com os Opcodes,
certo? Certo! E √© por isso que a <strong>extens√£o Opcache</strong>
existe.</p>
<h2>A extens√£o Opcache</h2>
<p>A extens√£o Opcache √© compilada com o PHP e normalmente
n√£o h√° motivos pra desativ√°-la. Se voc√™ usa PHP, voc√™
provavelmente deveria mant√™-la ativa.</p>
<p>O que essa extens√£o faz √© adicionar uma camada de cache
em mem√≥ria para os Opcodes. Sua fun√ß√£o √© pegar os Opcodes
rec√©m gerados atrav√©s da AST e jog√°-los num cache para que
as pr√≥ximas execu√ß√µes possam facilmente pular as fases
de Lexing e Parsing.</p>
<p>Aqui vai outro diagrama, desta vez considerando a
extens√£o Opcache:</p>
<figure style="text-align: center">
  <a href="/assets/images/posts/10-php-8-jit/zendvm-opcache.png" target="_blank">
    <img src="/assets/images/posts/10-php-8-jit/zendvm-opcache.png" alt="Fluxo de interpreta√ß√£o do PHP com Opcache.">
  </a>
  <figcaption>Fluxo de interpreta√ß√£o do PHP com Opcache. Se um arquivo j√° foi interpretado, o php busca o Opcode em cache em vez de realizar o parsing novamente.</figcaption>
</figure>
<p>Lindo ver como ele pula os passos de Lexing, Parsing e Compiling üòç.</p>
<p><strong>Nota:</strong> aqui √© justamente onde
<a href="https://wiki.php.net/rfc/preload">a fun√ß√£o de preloading do PHP 7.4</a>
brilha! Ela permite que voc√™ diga ao PHP FPM pra
fazer o parsing do seu c√≥digo fonte, transform√°-lo
em Opcodes e jogar no cache antes mesmo de executar
qualquer c√≥digo seu.</p>
<p>Voc√™ deve estar se perguntando onde o JIT entra
nessa hist√≥ria, n√©?! Bom, espero que sim, √© o motivo
de eu ter gastado tanto tempo nesse texto no fim
das contas...</p>
<h2>O que o Just In Time compiler faz efetivamente?</h2>
<p>Ap√≥s escutar a explica√ß√£o do Zeev no <a href="https://phpinternals.news/7">epis√≥dio PHP and JIT do PHP Internals News</a>
eu consegui ter alguma ideia sobre o que o JIT
deveria fazer...</p>
<p>Se o Opcache faz com que a obten√ß√£o de Opcodes
seja mais r√°pida para que possam ir direto para
a Zend VM, o JIT faz com que eles executem sem
Zend VM nenhuma.</p>
<p>A Zend VM √© um programa escrito em C que age
como uma camada entre Opcodes e a CPU. <strong>O que
o JIT faz √© gerar c√≥digo compilado em tempo de
execu√ß√£o para que o php possa pular a Zend VM e
executar diretamente na CPU.</strong>
Te√≥ricamente a gente deveria ganhar em performance
com isso.</p>
<p>Isto me soou estranho num primeiro momento, porque
pra compilar c√≥digo de m√°quina √© preciso escrever
uma implementa√ß√£o beeem espec√≠fica para cada tipo
de arquitetura. Mas na realidade √© bem plaus√≠vel.</p>
<p>A implementa√ß√£o do JIT em PHP usa uma biblioteca
chamada <a href="https://luajit.org/dynasm.html">DynASM (Dynamic Assembler)</a>,
que mapeia uma s√©rie de instru√ß√µes de CPU de um
formato espec√≠fico em c√≥digo assembly para v√°rios
tipos diferentes de CPU. Ent√£o o Just In Time compiler
transforma Opcodes em c√≥digo de m√°quina espec√≠fico
da arquitetura da CPU usando DynASM.</p>
<p>Mas tem uma coisa me deixou encafifado por um temp√£o...</p>
<p><strong>Se o preloading √© capaz de transformar PHP em Opcode
antes de executar qualquer coisa e o DynASM pode compilar
Opcodes em c√≥digo de m√°quina (compila√ß√£o Just In Time),
por qu√™ raios a gente n√£o compila PHP em c√≥digo de m√°quina
usando a cl√°ssica Ahead of Time compilation?!</strong></p>
<p>Uma das pistas que eu tive ao escutar o epis√≥dio
do Zeev √© que o PHP √© fracamente tipado e, portanto,
o PHP com frequ√™ncia n√£o sabe qual o tipo de uma
certa vari√°vel at√© que a Zend VM tente executar
um Opcode nela.</p>
<p>Isto pode ser percebido ao olhar para o <a href="https://github.com/php/php-src/blob/43443857b74503246ee4ca25859b302ed0ebc078/Zend/zend_types.h#L282-L300">union type zend_value</a>
, que possui v√°rios ponteiros de diferentes
representa√ß√µes para uma vari√°vel. Sempre que a Zend
VM tenta obter um valor de um zend_value, ela utiliza
macros como a <a href="https://github.com/php/php-src/blob/43443857b74503246ee4ca25859b302ed0ebc078/Zend/zend_types.h#L794">ZSTR_VAL</a>
que tenta acessar o ponteiro de string atrav√©s do
union zend_value.</p>
<p>Por exemplo, <a href="https://github.com/php/php-src/blob/43443857b74503246ee4ca25859b302ed0ebc078/Zend/zend_vm_def.h#L722-L767">este handler da Zend VM</a>
deveria tratar uma express√£o de &quot;Menor ou Igual&quot; (&lt;=).
Repare bem em como existe uma porrada de if conditions
pra tentar adivinhar os tipos dos operandos.</p>
<p><strong>Duplicar esta l√≥gica de infer√™ncia de tipos com
c√≥digo de m√°quina n√£o √© uma tarefa trivial e
potencialmente tornaria a execu√ß√£o mais lenta.</strong></p>
<p>Compilar tudo depois de entender os tipos tamb√©m
n√£o √© a melhor op√ß√£o, porque compilar algo para
c√≥digo de m√°quina requer muita CPU. Ent√£o compilar
TUDO em tempo de execu√ß√£o tamb√©m √© ruim.</p>
<h2>Como o Just In Time compiler se comporta?</h2>
<p>Agora sabemos que n√£o podemos inferir tipos
para gerar uma compila√ß√£o Ahead of Time boa o
suficiente. Tamb√©m sabemos que compilar em
tempo de execu√ß√£o √© custoso. Como pode ent√£o o
JIT ser ben√©fico para o PHP?</p>
<p>Para balancear esta equa√ß√£o, o JIT tenta compilar
apenas alguns Opcodes que ele considera que o
esfor√ßo valer√° a pena. Para tal, <strong>o JIT faz um
profiling dos Opcodes executados pela Zend VM e
verifica quais fazem sentido ou n√£o compilar.
(baseado em suas configura√ß√µes)</strong></p>
<p>Quando determinado Opcode √© compilado, ele ent√£o
delega a execu√ß√£o a este c√≥digo compilado em
vez de delegar para a Zend VM. Se parece com o
seguinte:</p>
<figure style="text-align: center">
  <a href="/assets/images/posts/10-php-8-jit/zendvm-opcache-jit.png" target="_blank">
    <img src="/assets/images/posts/10-php-8-jit/zendvm-opcache-jit.png" alt="Fluxo de interpreta√ß√£o do PHP com JIT.">
  </a>
  <figcaption>Fluxo de interpreta√ß√£o do PHP com JIT. Se compilado, Opcodes n√£o executam atrav√©s da Zend VM.</figcaption>
</figure>
<p>Ent√£o na extens√£o Opcache existem algumas
instru√ß√µes tentando detectar se determinados
Opcodes deveriam ser compilados ou n√£o. Caso sim,
o compilador ent√£o transforma este Opcode em
c√≥digo de m√°quina utilizando DynASM e executa
este c√≥digo de m√°quina rec√©m gerado.</p>
<p>A coisa interessante nisso tudo √© que existe
um limite em megabytes para o c√≥digo compilado
nesta implementa√ß√£o (tamb√©m configur√°vel), e
a execu√ß√£o de c√≥digo deve ser capaz de alternar
entre JIT e c√≥digo interpretado sem diferen√ßa
alguma.</p>
<p>A prop√≥sito, <a href="https://afup.org/talks/3015-php-8-et-just-in-time-compilation">esta palestra do Benoit Jacquemont sobre JIT no PHP</a>
me ajudous demaaais a entender essa coisa toda.</p>
<p>Eu ainda n√£o tenho muita certeza sobre quando
a compila√ß√£o efetivamente acontece, mas penso
que por agora eu n√£o quero saber, n√£o.</p>
<h2>Ent√£o provavelmente os ganhos em performance n√£o ser√£o enormes</h2>
<p>Eu espero que agora esteja um tanto mais claro
o motivo de todo mundo dizer que a maioria das
aplica√ß√µes PHP n√£o receberem grandes melhorias em
performance usando o Just In Time compiler. E o
o motivo de o Zeev ter recomendado fazer
experimenta√ß√µes com diferentes configura√ß√µes de
JIT em suas aplica√ß√µes PHP.</p>
<p>Os Opcodes compilados ser√£o normalmente compartilhados
entre v√°rias requests se voc√™ estiver utilizando o
PHP FPM, mas isto ainda n√£o √© grande coisa.</p>
<p>O motivo √© que o JIT otimiza opera√ß√µes de CPU, e
a maior parte das aplica√ß√µes PHP hoje em dia s√£o
mais focadas em opera√ß√µes de E/S (I/O) do que
qualquer coisa. N√£o importa se o processamento
das opera√ß√µes for compilado se voc√™ precisar
acessar disco ou rede de qualquer forma. Os
tempos de execu√ß√£o ser√£o bem similares.</p>
<p><strong>A n√£o ser que...</strong></p>
<p>Voc√™ esteja fazendo algo que n√£o envolve E/S,
como processamento de imagens ou machine learning.
Qualquer coisa que n√£o toque I/O ir√° se beneficiar
do Just In Time compiler.</p>
<p>Esta tamb√©m √© a raz√£o de algumas pessoas citarem
que agora estamos mais pr√≥ximos de poder escrever
fun√ß√µes PHP nativas, escritas em PHP em vez de C.
O peso adicional n√£o ser√° custoso se estas fun√ß√µes
forem compiladas.</p>
<p>Tempos interessantes para ser um(a) programador(a) PHP...</p>
<hr />
<p>Eu espero que este artigo lhe tenha sido √∫til e
que voc√™ tenha conseguido entender melhor o que
o JIT do PHP 8 faz.</p>
<p>Sinta-se convidado(a) a me escrever no twitter se
voc√™ gostaria de adicionar alguma coisa que eu possa
ter esquecido e n√£o se esque√ßa de compartilhar com
seus(uas) coleguinhas programadores(as), isto com
total certeza ir√° adicionar muito valor √† conversa
de voc√™s!</p>
<div class="align-right">
  --
  <a href="https://twitter.com/nawarian" rel="nofollow">
    @nawarian
  </a>
</div>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "Just In Time Compiler e o PHP 8",
  "description": "O Just In Time compiler do PHP 8 foi implementado como parte da extens&atilde;o Opcache e pretende compilar alguns Opcodes em instru&ccedil;&otilde;es de CPU em tempo de execu&ccedil;&atilde;o. Bora entender como isso funciona por baixo dos panos.",
  "image": [
    "https://thephp.website/assets/images/posts/10-php-8-jit-640.webp"
   ],
  "datePublished": "2020-03-03T00:00:00+08:00",
  "dateModified": "2020-03-03T00:00:00+08:00",
  "author": {
    "@type": "Person",
    "name": "Nawarian N&iacute;ckolas Da Silva"
  },
   "publisher": {
    "@type": "Organization",
    "name": "ThePHP Website",
    "logo": {
      "@type": "ImageObject",
      "url": "https://thephp.website/favicon.ico"
    }
  }
}
</script>  </div>
  </article>
</body>
<script src="/assets/build/js/main.js?id=859740b518dcddb1fe42"></script>
</html>
