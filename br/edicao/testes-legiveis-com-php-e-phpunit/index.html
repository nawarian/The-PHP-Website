<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <link rel="stylesheet" href="/assets/build/css/main.css?id=bf2bc72a5feb7957052d">
  <link
    rel="alternate"
    type="application/json"
    title="[BR] thePHP Website"
    href="https://thephp.website/br/feed.json"
  />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="[BR] thePHP Website"
    href="https://thephp.website/br/feed.xml"
  />
  
  <title>Testes leg√≠veis com PHP e PHPUnit | thePHP Website</title>

  <meta name="description" content="Este post tem a inten√ß√£o de lhe ajudar a reduzir o n√∫mero de &quot;Diab√©iss&quot; por segundo enquanto escreve, l√™ e muda c√≥digo de teste em sua aplica√ß√£o PHP usando o framework de testes PHPUnit.">

  <meta property="og:title" content="Testes leg√≠veis com PHP e PHPUnit">
  <meta property="og:description" content="Este post tem a inten√ß√£o de lhe ajudar a reduzir o n√∫mero de &quot;Diab√©iss&quot; por segundo enquanto escreve, l√™ e muda c√≥digo de teste em sua aplica√ß√£o PHP usando o framework de testes PHPUnit.">
  <meta property="og:url" content="https://thephp.website/br/edicao/testes-legiveis-com-php-e-phpunit">
  <meta property="og:image" content="https://thephp.website/assets/images/posts/4-writing-great-tests-640.webp">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@nawarian">
  <meta name="twitter:title" content="Testes leg√≠veis com PHP e PHPUnit">
  <meta name="twitter:description" content="Este post tem a inten√ß√£o de lhe ajudar a reduzir o n√∫mero de &quot;Diab√©iss&quot; por segundo enquanto escreve, l√™ e muda c√≥digo de teste em sua aplica√ß√£o PHP usando o framework de testes PHPUnit.">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151169766-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-151169766-3');
  </script>
  <script data-ad-client="ca-pub-3681134868307419" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- Hotjar Tracking Code for thephp.website -->
  <script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1770868,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
  </script>
  <script>
    function toggleMenu() {
      document.querySelector('.menu__container').classList.toggle('menu__container--active');
    }
  </script>
</head>
<body class="yue non-article">
  <header class="menu">
    <a class="menu__logo" href="/br/">
      <img src="/assets/images/elephpant-idle.png" alt="" />
    </a>
    <div class="menu__title">
      <a href="/br/">thePHP Website</a>
    </div>
    <section class="menu__cta">
      <button role="button" aria-label="Open Menu" class="menu__cta__icon" onclick="typeof toggleMenu == 'function' &amp;&amp; toggleMenu()">
        <img alt="Open Menu" src="https://podentender.com/assets/images/icons/menu.svg">
      </button>
    </section>

    <div class="menu__container">
      <em class="menu__section-heading">
        Pages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/br/">Home</a>
        </li>
        <li class="menu__list-item">
          <a href="/br/busca">
            busca.php
          </a>
        </li>
        <li class="menu__list-item">
          <a
            href="https://github.com/nawarian/The-PHP-Website/issues/new?title=[Suggested+Topic]%20&body=Please+describe+your+suggestion+/+Por+favor+descreva+sua+sugest√£o"
            rel="nofollow"
          >
            Pe√ßa um Post!
          </a>
        </li>
        <li class="menu__list-item">
          <a href="/br/sobre/">
            sobre.php
          </a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Languages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/en/">English</a>
        </li>
        <li class="menu__list-item">
          <a href="/br/">Portugu√™s</a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Notifications.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="https://thephp.website/br/feed.json">
            [BR] JSON Feed
          </a>
        </li>
        <li class="menu__list-item">
          <a href="https://thephp.website/br/feed.xml">
            [BR] Atom Feed (RSS)
          </a>
        </li>
                <li class="menu__list-item">
          <a href="https://thephp.website/br/feed-vagas.xml">
            Feed de Vagas (RSS)
          </a>
        </li>
              </ul>
    </div>
  </header>
  <article class="container">
      <div class="article">
    <time datetime="2020-01-07">
      2020-01-07
    </time>

    <h1>Testes leg√≠veis com PHP e PHPUnit</h1>
    <p><a href="/en/issue/clean-tests-with-php-and-phpunit/">Read in English</a></p>
<p>Existem v√°rias ferramentas dispon√≠veis no ecossistema PHP que est√£o preparadas
para oferecer uma √≥tima experi√™ncia com testes.
<a href="https://github.com/sebastianbergmann/phpunit">PHPUnit √© de longe a mais famosa de todas</a>
. √â quase um sin√¥nimo de teste nessa linguagem.</p>
<p>As boas pr√°ticas n√£o s√£o bem compartilhadas na comunidade. Existem tantas
op√ß√µes de quando e por qu√™ escrever testes, quais tipos de testes e por
a√≠ vai. Mas na verdade <strong>n√£o faz sentido algum escrever qualquer teste
se voc√™ n√£o for capaz de l√™-los mais tarde</strong>.</p>
<h2>Testes s√£o uma forma muito especial de documenta√ß√£o</h2>
<p>Como eu j√° mencionei no <a href="/br/edicao/tdd-com-php-na-vida-real/">post sobre TDD com PHP</a>,
um teste sempre vai (ou pelo menos deveria) tornar claro o que um certo
peda√ßo de c√≥digo deve atingir como objetivo.</p>
<p><strong>Se um teste n√£o consegue expressar uma ideia, √© um teste ruim.</strong></p>
<p>Com isso em mente, eu preparei uma lista com boas pr√°ticas que podem
auxiliar desenvolvedores(as) php a escrever testes bons, leg√≠veis e
√∫teis.</p>
<h2>Come√ßando pelo b√°sico</h2>
<p>Existem algumas pr√°ticas que muitas pessoas seguem sem sequer questionar o
motivo. Eu vou listar algumas delas e tentar explicar pelo menos por cima
qual a raz√£o de tais pr√°ticas.</p>
<h3>Testes n√£o deveriam fazer opera√ß√µes E/S</h3>
<p><strong>Motivo</strong>: E/S √© lento e inst√°vel.</p>
<p><strong>Lento:</strong> mesmo com o melhor equipamento na face da terra, E/S ainda ser√°
mais lento que acesso a mem√≥ria. <strong>Testes devem sempre rodar r√°pido</strong>, do
contr√°rio ningu√©m ir√° rod√°-los suficientemente.</p>
<p><strong>Inst√°vel:</strong> um certo arquivo, bin√°rio, socket, pasta ou entrada DNS pode
n√£o estar dispon√≠vel em todas as m√°quinas em que seu c√≥digo ser√° executado.
<strong>Quanto mais voc√™ depende de E/S em seus testes, mais seus testes ficam
amarrados e dependentes de infraestrutura</strong>. </p>
<p>Opera√ß√µes consideradas E/S:</p>
<ul>
<li>Ler/escrever arquivos</li>
<li>Chamadas de rede</li>
<li>Chamadas a processos externos (usando exec, proc_open...)</li>
</ul>
<p>Existem casos onde ter E/S far√° com que o teste seja escrito mais rapidamente.
<strong>Mas se liga</strong>: fazer com que essas opera√ß√µes funcionem da mesma forma nos
ambientes de desenvolvimento, build e deployment pode se tornar uma imensa
dor de cabe√ßa.</p>
<p><strong>Isolando testes para que n√£o precisam de E/S:</strong> abaixo eu mostro
uma decis√£o de design que pode ser tomada para evitar que seus testes
realizem opera√ß√µes de E/S <strong>segregando responsabilidades para interfaces</strong>.</p>
<p>Segue o exemplo:</p>
<pre><code class="language-php">public function getPeople(): array
{
  $rawPeople = file_get_contents(
    'people.json'
  ) ?? '[]';

  return json_decode(
    $rawPeople,
    true
  );
}</code></pre>
<p>No momento em que come√ßarmos a testar este m√©todo, seremos for√ßados a
criar um arquivo local pra teste e, de tempos em tempos, manter uma
snapshot desse arquivo. Como no seguinte:</p>
<pre><code class="language-php">public function testGetPeopleReturnsPeopleList(): void
{
  $people = $this-&gt;peopleService
    -&gt;getPeople();

  // assert it contains people
}</code></pre>
<p>Pra esse tipo, √© necess√°rio <strong>definir pr√© condi√ß√µes</strong> para que ele possa passar.
Mesmo que pare√ßa fazer sentido a primeira vista, isto √© na realidade <strong>terr√≠vel</strong>.</p>
<p><strong>Pular um teste por conta de uma pr√© condi√ß√£o faltante n√£o garante qualidade de
software. Apenas esconde bugs!</strong></p>
<p><strong>Corrigindo:</strong> basta isolar as opera√ß√µes de E/S ao mover a responsabilidade para
uma interface.</p>
<pre><code class="language-php">// extrai a l√≥gica
// de buscar algo
// p/ uma interface
// especializada
interface PeopleProvider
{
  public function getPeople(): array;
}

// implementa√ß√£o concreta
class JsonFilePeopleProvider
  implements PeopleProvider
{
  private const PEOPLE_JSON =
    'people.json';

  public function getPeople(): array
  {
    $rawPeople = file_get_contents(
      self::PEOPLE_JSON
    ) ?? '[]';

    return json_decode(
      $rawPeople,
      true
    );
  }
}

class PeopleService
{
  // injetar via __construct()
  private PeopleProvider $peopleProvider;

  public function getPeople(): array
  {
    return $this-&gt;peopleProvider
      -&gt;getPeople();
  }
}</code></pre>
<p>T√¥ sabendo, agora <code>JsonFilePeopleProvider</code> usa E/S de toda forma. Verdade.</p>
<p>Em vez de <code>file_get_contents()</code> a gente pode usar um layer de abstra√ß√£o
como o <a href="https://flysystem.thephpleague.com/docs/adapter/local/">Filesystem do Flysystem</a>
que pode ser facilmente mockado.</p>
<p>E pra qu√™ serve o <code>PeopleService</code> ent√£o? Boa pergunta... Isto √© uma das coisas
que <strong>testes nos traz: questionar o nosso design, remover c√≥digo inutil.</strong></p>
<hr>
<h3>Testes devem ser concisos e ter significado</h3>
<p><strong>Motivo:</strong> testes s√£o uma forma de documenta√ß√£o. Mantenha-os limpos,
curtos e leg√≠veis.</p>
<p><strong>Limpos e curtos</strong>: sem bagun√ßa, sem escrever mil linhas de mock,
sem escrever trocentos asserts no mesmo teste.</p>
<p><strong>Leg√≠veis:</strong> cada teste deve contar uma hist√≥ria. A estrutura &quot;Given, When, Then&quot;
√© perfeita pra isso.</p>
<p>Aqui v√£o algumas caracter√≠sticas de um teste bem escrito:</p>
<ul>
<li>Cont√©m apenas asserts necess√°rios (preferivelmente apenas um)</li>
<li>Lhe conta exatamente o que deveria acontecer dada certa condi√ß√£o</li>
<li>Testa apenas um caminho de execu√ß√£o do m√©todo por vez</li>
<li>N√£o mocka o universo inteiro para fazer algum assert</li>
</ul>
<p><strong>Importante notar</strong> que se a sua implementa√ß√£o possui alguns IFs, switch ou
itera√ß√µes, <strong>todos estes caminhos alternativos devem ser explicitamente testados.</strong>
Ent√£o early returns, por exemplo, devem sempre conter testes.</p>
<p>Novamente: <strong>n√£o importa o coverage, o que importa √© documentar.</strong></p>
<p>Deixa eu te mostrar como um teste confuso se parece:</p>
<pre><code class="language-php">public function testCanFly(): void
{
  $semAsas = new Person(0);
  $this-&gt;assertEquals(
    false,
    $semAsas-&gt;canFly()
  );

  $umaAsa = new Person(1);
  $this-&gt;assertTrue(
    !$$umaAsa-&gt;canFly()
  );

  $duasAsas = new Person(2);
  $this-&gt;assertTrue(
    $$duasAsas-&gt;canFly()
  );
}</code></pre>
<p>Vamos ent√£o adotar o &quot;Given, When, Then&quot; e ver como esse teste muda:</p>
<pre><code class="language-php">public function testCanFly(): void
{
  // Given
  $person = $this-&gt;givenAPersonHasNoWings();

  // Then
  $this-&gt;assertEquals(
    false,
    $person-&gt;canFly()
  );

  // Outros casos...
}

private function givenAPersonHasNoWings(): Person
{
  return new Person(0);
}</code></pre>
<p>Assim como as cl√°usulas &quot;Given&quot;, os &quot;When&quot;s e &quot;Then&quot;s tamb√©m podem
ser extra√≠dos para m√©todos privados. Qualquer coisa que fa√ßa seu
teste ficar mais leg√≠vel.</p>
<p>Agora, aquele assertEquals t√° bem bagun√ßado e com pouqu√≠ssimo significado.
Um humano lendo isso precisa interpretar a assertion pra entender o que
deveria significar.</p>
<p><strong>Usar assertions espec√≠ficas tornam seus testes muito mais leg√≠veis.</strong>
<code>assertTrue()</code> deveria receber uma vari√°vel contendo um booleano, nunca
uma express√£o como <code>canFly() !== true</code>.</p>
<p>Ent√£o do exemplo anterior, vamos substituir o <code>assertEquals</code> entre <code>false</code>
e <code>$person-&gt;canFly()</code> com um simples <code>assertFalse</code>:</p>
<pre><code class="language-php">// ...
$person = $this-&gt;givenAPersonHasNoWings();

$this-&gt;assertFalse(
  $person-&gt;canFly()
);

// Outros casos...</code></pre>
<p>Limpinho! Dado que uma pessoa n√£o tem asas, ela n√£o deveria poder voar!
D√° pra ler como se fosse um poema üòç</p>
<p>Agora, esse &quot;Outros casos&quot; aparecendo duas vezes no nosso texto j√° √© uma
boa pista de que este teste est√° fazendo muitas assertions. Ao mesmo tempo
o nome do m√©todo <code>testCanFly()</code> n√£o significa nada muito √∫til.</p>
<p>Vamos tornar o nosso test case um tequinho melhor:</p>
<pre><code class="language-php">public function testCanFlyIsFalsyWhenPersonHasNoWings(): void
{
  $person = $this-&gt;givenAPersonHasNoWings();
  $this-&gt;assertFalse(
    $person-&gt;canFly()
  );
}

public function testCanFlyIsTruthyWhenPersonHasTwoWings(): void
{
  $person = $this-&gt;givenAPersonHasTwoWings();
  $this-&gt;assertTrue(
    $person-&gt;canFly()
  );
}

// ...</code></pre>
<p>A gente poderia inclusive renomear o teste pra bater com um cen√°rio da
vida real como <code>testPersonCantFlyWithoutWings</code>, mas pra mim o nome j√°
parece bom o suficiente.</p>
<hr>
<h3>Um teste n√£o deve depender de outro</h3>
<p><strong>Motivo:</strong> um teste deveria ser capaz de rodar e passar em qualquer ordem.</p>
<p>At√© o presente momento, eu n√£o consigo encontrar um bom motivo para acoplar
testes.</p>
<p>Recentemente eu fui perguntado sobre como testar uma feature para usu√°rios
logados e eu gostaria de utilizar isto como exemplo aqui.</p>
<p>O teste faria o seguinte:</p>
<ul>
<li>Gerar um token JWT</li>
<li>Executar uma certa tarefa logado</li>
<li>Fazer os asserts</li>
</ul>
<p>A forma como o teste foi feito era a seguinte:</p>
<pre><code class="language-php">public function testGenerateJWTToken(): void
{
  // ... $token
  $this-&gt;token = $token;
}

// @depends  testGenerateJWTToken
public function testExecuteAnAmazingFeature(): void
{
  // Execute using $this-&gt;token
}

// @depends  testExecuteAnAmazingFeature
public function testStateIsBlah(): void
{
  // Busca os resultados
  // interface logada
}</code></pre>
<p>Este teste √© ruim por alguns motivos:</p>
<ul>
<li>PHPUnit n√£o garantir√° a ordem de execu√ß√£o dos testes</li>
<li>Os testes n√£o podem ser executados de forma independente</li>
<li>Testes rodando em paralelo ir√£o falhar aleatoriamente</li>
</ul>
<p>A forma mais simples de resolver este problema que eu consigo pensar,
novamente, √© com &quot;Given, When, Then&quot;. Desta forma a gente torna os
testes mais concisos e conta uma hist√≥ria ao mostrar suas depend√™ncias
de forma clara que explica a feature em si.</p>
<pre><code class="language-php">public function testAmazingFeatureChangesState(): void
{
  // Given
  $token = $this-&gt;givenImAuthenticated();

  // When
  $this-&gt;whenIExecuteMyAmazingFeature(
    $token
  );
  $newState = $this-&gt;pollStateFromInterface(
    $token
  );

  // Then
  $this-&gt;assertEquals(
    'my-state',
    $newState
  );
}</code></pre>
<p>A gente precisaria tamb√©m escrever testes para autenticar e por a√≠ vai.
Esta estrutura √© t√£o massa que o
<a href="https://behat.org/en/latest/quick_start.html">Behat a utiliza por padr√£o</a>.</p>
<hr>
<h3>Sempre injete as depend√™ncias</h3>
<p><strong>Motivo:</strong> mockar estado global √© terr√≠vel, n√£o ser capaz de mockar as
depend√™ncias torna imposs√≠vel testar uma funcionalidade.</p>
<p>Aqui vai uma li√ß√£o para a vida: <strong>Esque√ßa sobre classes est√°ticas que mant√©m
estado e tamb√©m inst√¢ncias singleton.</strong> Se a sua classe depende de algo,
torne-o injet√°vel.</p>
<p>Aqui vai um exemplo particularmente triste:</p>
<pre><code class="language-php">class FeatureToggle
{
  public function isActive(
    Id $feature
  ): bool {
    $cookieName = $feature-&gt;getCookieName();

    // Early return se o
    // cookie est√° presente
    if (Cookies::exists(
      $cookieName
    )) {
      return Cookies::get(
        $cookieName
      );
    }

    // Calcular feature toggle...
  }
}</code></pre>
<p>Agora. Como voc√™ poderia testar este early return?</p>
<p>N√£o consegue n√©, Mois√©s?</p>
<p>Pra testar este m√©todo, n√≥s precisar√≠amos entender o comportamento
desta classe <code>Cookies</code> e tomar certeza de que conseguir√≠amos reproduzir
todo o ambiente por tr√°s desta classe para for√ßar alguns retornos.</p>
<p>Faz isso n√£o.</p>
<p>A gente pode consertar essa situa√ß√£o injetando uma inst√¢ncia de <code>Cookies</code>
como depend√™ncia. O teste ficaria parecido com o seguinte:</p>
<pre><code class="language-php">// Test class...
private Cookies $cookieMock;

private FeatureToggle $service;

// Preparing our service and dependencies
public function setUp(): void
{
  $this-&gt;cookieMock = $this-&gt;prophesize(
    Cookies::class
  );

  $this-&gt;service = new FeatureToggle(
    $this-&gt;cookieMock-&gt;reveal()
  );
}

public function testIsActiveIsOverriddenByCookies(): void
{
  // Given
  $feature = $this-&gt;givenFeatureXExists();

  // When
  $this-&gt;whenCookieOverridesFeatureWithTrue(
    $feature
  );

  // Then
  $this-&gt;assertTrue(
    $this-&gt;service-&gt;isActive($feature)
  );
  // poder√≠amos tamb√©m testar que
  // nenhum outro m√©todo foi chamado
}

private function givenFeatureXExists(): Id
{
  // ...
  return $feature;
}

private function whenCookieOverridesFeatureWithTrue(
  Id $feature
): void {
  $cookieName = $feature-&gt;getCookieName();
  $this-&gt;cookieMock-&gt;exists($cookieName)
    -&gt;shouldBeCalledOnce()
    -&gt;willReturn(true);

  $this-&gt;cookieMock-&gt;get($cookieName)
    -&gt;shouldBeCalledOnce()
    -&gt;willReturn(true);
}</code></pre>
<p><strong>O mesmo acontece com singletons.</strong> Ent√£o se voc√™ quer <strong>tornar um objeto
√∫nico</strong>, √© s√≥ <strong>configurar o seu injetor de depend√™ncias direito</strong> em vez
de utilizar o Singleton (anti) pattern.</p>
<p>Do contr√°rio voc√™ vai acabar escrevendo m√©todos como <code>reset()</code> ou
<code>setInstance()</code>, que s√≥ s√£o √∫teis para classes de teste. Me soa no
m√≠nimo estranho. </p>
<p>Mudar o seu desgin para tornar testes mais simples est√° tudo bem. <strong>Criar
m√©todos para tornar testes mais simples n√£o est√° ok.</strong></p>
<hr>
<h3>Nunca teste m√©todos protected/private</h3>
<p><strong>Motivo:</strong> a forma como testamos uma funcionalidade √© fazendo assertions
em como a sua assinatura se comporta: dada uma condi√ß√£o, quando eu fa√ßo X,
espero que Y aconte√ßa.
<strong>M√©todos protected/private n√£o s√£o parte da assinatura de uma funcionalidade.</strong></p>
<p>Eu vou inclusive me recusar a te mostrar uma forma de &quot;testar&quot; m√©todos privados,
mas aqui vai uma dica: voc√™ fazer isso com a <a href="https://www.php.net/manual/en/book.reflection.php">reflection API</a>.</p>
<p>Por favor, castigue-se de alguma forma sempre que pensar em utilizar reflections
pra testar um m√©todo privado!</p>
<p>Por defini√ß√£o, m√©todos privados v√£o somente ser chamados de dentro da classe.
Ent√£o n√£o s√£o publicamente acess√≠veis. Isto significa que apenas m√©todos
p√∫blicos nesta mesma classe consegue invocar tais m√©todos privados.</p>
<p><strong>Se voc√™ testou todos os m√©todos p√∫blicos, voc√™ tamb√©m deve ter testado os
protegidos/privados de uma vez s√≥.</strong> Se n√£o, pode apagar cada um deles, que
ningu√©m t√° usando eles mesmo.</p>
<hr>
<h2>Al√©m do b√°sico: as coisas interessantes</h2>
<p>Espero que voc√™ n√£o tenha ficado entediado(a) at√© aqui. B√°sico √© b√°sico, mas
precisa ser escrito.</p>
<p>Agora, durante as pr√≥ximas linhas, vou compartilhar contigo algumas opini√µes
que carrego sobre testes limpos e cada decis√£o que impacta meu fluxo de
desenvolvimento.</p>
<p><strong>Eu diria que os valores mais importantes que levo em considera√ß√£o enquanto
escrevo testes s√£o os seguintes:</strong></p>
<ul>
<li>Aprendizado</li>
<li>Receber feedback r√°pido</li>
<li>Documenta√ß√£o</li>
<li>Refatora√ß√£o</li>
<li>Design enquanto testo</li>
</ul>
<p>Cada opini√£o que exponho abaixo segue ao menos um destes valores e cada
uma d√° suporte √† outra.</p>
<h3>Teste vem primeiro, n√£o depois</h3>
<p><strong>Valores</strong>: aprendizado, receber feedback r√°pido, documenta√ß√£o, refatora√ß√£o,
design enquanto testo.</p>
<p>Esta √© a base de tudo. √â t√£o importante que carrega todos os valores de uma
vez s√≥.</p>
<p>Escrever teste primeiro lhe for√ßa entender como o seu &quot;given, when, then&quot;
deve ser estruturado. <strong>Voc√™ documenta primeiro ao escrever assim</strong> e,
mais importante ainda, <strong>aprende e torna expl√≠cito seus requisitos</strong> como
coisas mais relevantes no software.</p>
<p><strong>Te parece estranho escrever um teste antes de escrever algo?</strong> Imagine
o qu√£o embara√ßoso √© implementar algo e, enquanto testa, descobrir que todos
os &quot;given, when, then&quot; n√£o t√™m sentido algum.</p>
<p>Testar primeiro tamb√©m te permite rodar os testes contra as expectativas a
cada 2 segundos. <strong>Voc√™ recebe feedback de suas mudan√ßas da forma mais r√°pida
poss√≠vel. N√£o importa o qu√£o grande ou pequena a feature possa parecer.</strong></p>
<p><strong>Testes que est√£o passando indicam as melhores √°reas para refatorar no sistema.</strong>
Em algum momento eu provavelmente escreverei sobre refatora√ß√£o, mas a coisa √©:
sem teste, sem refatora√ß√£o. Porque refatorar sem testes √© simplesmente arriscado
demais.</p>
<p>E por √∫ltimo, mas n√£o menos importante, ao definir o seu &quot;given, when, then&quot;
fica claro quais interfaces seus m√©todos devem ter e como elas devem se
comportar. <strong>Manter este teste limpo tamb√©m ir√° lhe for√ßar a tomar diferentes
decis√µes de design.</strong></p>
<p>Ir√° lhe for√ßar a criar factories, interfaces, quebrar heran√ßas e por a√≠ vai.
E, sim, para tornar o teste mais simples!</p>
<p>Se seus testes s√£o um documento vivo que pretende explicar como o software
funciona, <strong>√© extremamente importante que eles expliquem de forma clara.</strong></p>
<hr>
<h3>N√£o ter testes √© melhor que ter testes mal feitos</h3>
<p><strong>Valores</strong>: aprendizado, documenta√ß√£o, refatora√ß√£o.</p>
<p>Muitos(as) desenvolvedores(as) escrevem teste da seguinte forma: escreve
a funcionalidade, soca o framework de teste at√© cobrir um certo tanto de
linhas e enviam pra produ√ß√£o.</p>
<p>O que eu gostaria que fosse levado em considera√ß√£o com mais frequ√™ncia, por√©m,
√© quando o(a) pr√≥ximo(a) desenvolvedor(a) visita esta funcionalidade. <strong>O que
os testes est√£o realmente contando a esta pessoa...</strong></p>
<p>Normalmente testes cujo nome n√£o dizem muita coisa, s√£o testes mal escritos.
O que √© mais claro pra ti: <code>testCanFly</code> ou
<code>testCanFlyReturnsFalseWhenPersonHasNoWings</code>?</p>
<p>Sempre que seu teste n√£o representar nada al√©m de bagun√ßa e c√≥digos for√ßando
ao framework aumentar o coverage com exemplos que n√£o parecem fazer qualquer
sentido, √© hora de parar e pensar se vale a pena escrever este teste.</p>
<p>At√© mesmo coisas bestas como nomear uma vari√°vel como <code>$a</code> e <code>$b</code>, ou dar nomes
que n√£o se relacionam com o caso de uso.</p>
<p><strong>Lembre-se:</strong> testes s√£o um documento vivo, tentando explicar como o software
deveria se comportar. <code>assertFalse($a-&gt;canFly())</code> n√£o documenta muita coisa.
J√° <code>assertFalse($personWithNoWingos-&gt;canFly())</code> documenta.</p>
<hr>
<h3>Rode seus testes compulsivamente</h3>
<p><strong>Valores</strong>: aprendizado, receber feedback r√°pido, refatora√ß√£o.</p>
<p><strong>Antes de iniciar qualquer funcionalidade: rode os testes.</strong> Se os testes
estiverem quebrados antes de voc√™ tocar qualquer coisa, voc√™ saber√° <em>antes</em>
de escrever qualquer c√≥digo e n√£o ir√° gastar preciosos minutos depurando
testes quebrados que voc√™ nem tinha conhecimento sobre.</p>
<p><strong>Ap√≥s salvar um arquivo: rode os testes.</strong> O quanto antes voc√™ souber que
quebrou algo, mais cedo saber√° como corrigir o problema e continuar. Se
interromper seu fluxo de trabalho para corrigir um problema te parece
improdutivo, imagina s√≥ voltar v√°rios passos atr√°s pra corrigir um problema
que voc√™ n√£o fazia ideia ter causado.</p>
<p><strong>Depois de trocar uma ideia com o(a) colega ou verificar suas notifica√ß√µes
do github: rode os testes.</strong> Se o teste estiver vermelho, voc√™ sabe onde
parou. Se estiverem verdes, voc√™ sabe que pode continuar.</p>
<p><strong>Antes de refatorar algo, at√© mesmo nomes de vari√°veis: rode os testes.</strong></p>
<p>S√©rio mesmo, rode os testes. √â de gra√ßa. Rode os testes com a mesma
frequ√™ncia em que salva seus arquivos.</p>
<p>Na real, o <a href="https://github.com/spatie/phpunit-watcher">PHPUnit Watcher</a>
resolve exatamente esse problema pra gente e at√© envia notifica√ß√£o
quando os testes rodam.</p>
<hr>
<h3>Grandes testes, grandes responsabilidades</h3>
<p><strong>Valores</strong>: aprendizado, refatora√ß√£o, design enquanto testo.</p>
<p>Seria ideal que cada classe teria ao menos um caso de teste pra si.
E tamb√©m que cada m√©todo p√∫blico fosse coberto com testes. E cada
fluxo alternativo (if/switch/try-catch/exception)...</p>
<p>Contemos mais ou menos assim:</p>
<ul>
<li>1 classe = 1 caso de teste</li>
<li>1 m√©todo = 1 ou mais testes</li>
<li>1 fluxo alternativo (if/switch/try-catch/exception) = 1 teste</li>
</ul>
<p>Ent√£o um c√≥digo simples como o abaixo deveria ter 4 testes diferentes:</p>
<pre><code class="language-php">// class Person
public function eatSlice(Pizza $pizza): void
{
  // testar exception
  if ([] === $pizza-&gt;slices()) {
    throw new LogicException('...');
  }

  // testar exception
  if (true === $this-&gt;isFull()) {
    throw new LogicException('...');
  }

  // testar caminho padr√£o (slices = 1)
  $slices = 1;
  // testar caminho alternativo (slices = 2)
  if (true === $this-&gt;isVeryHungry()) {
    $slices = 2;
  }

  $pizza-&gt;removeSlices($slices);
}</code></pre>
<p><strong>Quanto mais m√©todos p√∫blicos, mais testes.</strong></p>
<p>E ningu√©m gosta de ler documentos longos. Como seu caso de teste tamb√©m √©
um documento, deix√°-lo pequeno e conciso ir√° aumentar a sua qualidade e
utilidade.</p>
<p>Isto tamb√©m √© um grande sinal de que sua classe est√° acumulando
responsabilidades e pode ser hora de botar o chap√©u de refatora√ß√£o pra
remover funcionalidades, mover para classes diferentes ou repensar parte
do seu design.</p>
<hr>
<h3>Mantenha uma suite de regress√£o</h3>
<p><strong>Valores</strong>: aprendizado, documenta√ß√£o, receber feedback r√°pido. </p>
<p>Se liga nessa fun√ß√£o:</p>
<pre><code class="language-php">function findById(string $id): object
{
  return fromDb((int) $id);
}</code></pre>
<p>Voc√™ esperou algu√©m passar <code>"10"</code> mas, em vez disso, foi passado <code>"10 bananas"</code>.
Ambas formas acham o valor, mas uma n√£o deveria. Voc√™ tem um bug.</p>
<p>A primeira coisa a fazer? Escrever um teste que descreva que este comportamento
est√° errado!!</p>
<pre><code class="language-php">public function testFindByIdAcceptsOnlyNumericIds(): void
{
  $this-&gt;expectException(InvalidArgumentException::class);
  $this-&gt;expectExceptionMessage(
    'Only numeric IDs are allowed.'
  );

  findById("10 bananas");
}</code></pre>
<p>Testes n√£o est√£o passando, √© claro. Mas agora voc√™ sabe o que fazer para
faz√™-los passar. Remova o bug, fa√ßa o teste passar, joga no master,
d√° aquele deploy e vai ser feliz!</p>
<p>Mantenha este teste ali, pra sempre. Se poss√≠vel, numa suite de testes
especializada em regress√£o e conecte este teste com uma issue.</p>
<p>E prontinho! Feedback r√°pido enquanto corrige bugs, documenta√ß√£o feita,
c√≥digo a prova de regress√µes e felicidade.</p>
<hr>
<h2>Notas finais e bora trocar ideia</h2>
<p>Ufa, falei um monte ein... E √© claro que a maioria das coisas aqui s√£o
opini√µes minhas que desenvolvi conforme fui evoluindo na carreira. N√£o
est√£o certas ou erradas, s√£o apenas opini√µes.</p>
<p>Este post continuar√° crescendo conforme eu veja que alguns t√≥picos
importantes ficaram de fora.</p>
<p>Sinta-se sempre livre pra comentar e enviar d√∫vidas direto no meu twitter
ou pelo reposit√≥rio do projeto no Github. </p>
<div class="align-right">
  --
  <a href="https://twitter.com/nawarian" rel="nofollow">
    @nawarian
  </a>
</div>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "Testes leg&iacute;veis com PHP e PHPUnit",
  "description": "Este post tem a inten&ccedil;&atilde;o de lhe ajudar a reduzir o n&uacute;mero de \"Diab&eacute;iss\" por segundo enquanto escreve, l&ecirc; e muda c&oacute;digo de teste em sua aplica&ccedil;&atilde;o PHP usando o framework de testes PHPUnit.",
  "image": [
    "https://thephp.website/assets/images/4-writing-great-tests.jpg"
   ],
  "datePublished": "2020-01-07T00:00:00+08:00",
  "dateModified": "2020-01-07T00:00:00+08:00",
  "author": {
    "@type": "Person",
    "name": "Nawarian N&iacute;ckolas Da Silva"
  },
   "publisher": {
    "@type": "Organization",
    "name": "ThePHP Website",
    "logo": {
      "@type": "ImageObject",
      "url": "https://thephp.website/favicon.ico"
    }
  }
}
</script>  </div>
  </article>
</body>
<script src="/assets/build/js/main.js?id=fd09420d5a6aa331aa18"></script>
</html>
