<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <link rel="stylesheet" href="/assets/build/css/main.css?id=bf2bc72a5feb7957052d">
  <link
    rel="alternate"
    type="application/json"
    title="[BR] thePHP Website"
    href="https://thephp.website/br/feed.json"
  />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="[BR] thePHP Website"
    href="https://thephp.website/br/feed.xml"
  />
  
  <title>Tudo o que voc√™ precisa (e n√£o precisa) saber sobre Tipos no PHP | thePHP Website</title>

  <meta name="description" content="Este √© o melhor guias entre todos que voc√™ encontrar√° na internet sobre como o PHP lida com seus tipos internamente.">

  <meta property="og:title" content="Tudo o que voc√™ precisa (e n√£o precisa) saber sobre Tipos no PHP">
  <meta property="og:description" content="Este √© o melhor guias entre todos que voc√™ encontrar√° na internet sobre como o PHP lida com seus tipos internamente.">
  <meta property="og:url" content="https://thephp.website/br/edicao/tipos-em-php">
  <meta property="og:image" content="https://thephp.website/assets/images/posts/17-php-type-system-640.webp">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@nawarian">
  <meta name="twitter:title" content="Tudo o que voc√™ precisa (e n√£o precisa) saber sobre Tipos no PHP">
  <meta name="twitter:description" content="Este √© o melhor guias entre todos que voc√™ encontrar√° na internet sobre como o PHP lida com seus tipos internamente.">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151169766-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-151169766-3');
  </script>
  <script data-ad-client="ca-pub-3681134868307419" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- Hotjar Tracking Code for thephp.website -->
  <script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1770868,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
  </script>
  <script>
    function toggleMenu() {
      document.querySelector('.menu__container').classList.toggle('menu__container--active');
    }
  </script>
</head>
<body class="yue non-article">
  <header class="menu">
    <a class="menu__logo" href="/br/">
      <img src="/assets/images/elephpant-idle.png" alt="" />
    </a>
    <div class="menu__title">
      <a href="/br/">thePHP Website</a>
    </div>
    <section class="menu__cta">
      <button role="button" aria-label="Open Menu" class="menu__cta__icon" onclick="typeof toggleMenu == 'function' &amp;&amp; toggleMenu()">
        <img alt="Open Menu" src="https://podentender.com/assets/images/icons/menu.svg">
      </button>
    </section>

    <div class="menu__container">
      <em class="menu__section-heading">
        Pages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/br/">Home</a>
        </li>
        <li class="menu__list-item">
          <a href="/br/busca">
            busca.php
          </a>
        </li>
        <li class="menu__list-item">
          <a
            href="https://github.com/nawarian/The-PHP-Website/issues/new?title=[Suggested+Topic]%20&body=Please+describe+your+suggestion+/+Por+favor+descreva+sua+sugest√£o"
            rel="nofollow"
          >
            Pe√ßa um Post!
          </a>
        </li>
        <li class="menu__list-item">
          <a href="/br/sobre/">
            sobre.php
          </a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Languages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/en/">English</a>
        </li>
        <li class="menu__list-item">
          <a href="/br/">Portugu√™s</a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Notifications.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="https://thephp.website/br/feed.json">
            [BR] JSON Feed
          </a>
        </li>
        <li class="menu__list-item">
          <a href="https://thephp.website/br/feed.xml">
            [BR] Atom Feed (RSS)
          </a>
        </li>
                <li class="menu__list-item">
          <a href="https://thephp.website/br/feed-vagas.xml">
            Feed de Vagas (RSS)
          </a>
        </li>
              </ul>
    </div>
  </header>
  <article class="container">
      <div class="article">
    <time datetime="2020-07-29">
      2020-07-29
    </time>

    <h1>Tudo o que voc√™ precisa (e n√£o precisa) saber sobre Tipos no PHP</h1>
    <p><a href="/en/issue/php-type-system">Read in English</a></p>
<p><strong>PHP √© uma linguagem dinamicamente tipada</strong> e at√© o ano de 2015 quase
n√£o tinha suporte para declarar tipos de forma est√°tica. J√° era poss√≠vel
realizar um cast para tipos escalares de forma expl√≠cita no c√≥digo,
mas declarar tipos escalares em assinaturas de m√©todos e fun√ß√µes
n√£o era poss√≠vel at√© a chegada do PHP 7.0 com as RFCs
<a href="https://wiki.php.net/rfc/scalar_type_hints_v5">Scalar Type Declarations</a>
e <a href="https://wiki.php.net/rfc/return_types">Return Type Declarations</a>.</p>
<p>Mas isso n√£o significa que a partir da vers√£o 7.0 o PHP passou a ser
estaticamente tipado. <strong>O PHP possui type hints que podem ser analisados
de forma est√°tica</strong> mas <strong>ainda oferece suporte a tipos din√¢micos</strong> e,
inclusive, nos permite misturar os dois formatos.</p>
<p>Veja o exemplo abaixo:</p>
<pre><code class="language-php">&lt;?php

function retornaInt(): int
{
  return '100';
}</code></pre>
<p>Sem sombra de d√∫vidas <strong>tem um conflito de tipos a√≠ em cima</strong>. O retorno
deveria ser um <em>int</em> e o valor retornado √© na verdade uma <em>string</em>. O que
o PHP faz internamente √© automaticamente transformar o token '100' num
inteiro para poder retornar o tipo necess√°rio. Mesmo que pare√ßa trazer um
custo extra, n√£o √© o caso. O type juggling (malabarismo de tipos) do php
√© <em>quase</em> livre de processamento extra em muitos casos.</p>
<p>Para esclarecer de uma vez por todas como a linguagem lida com tipos, eu
escrevi este arquivo em sec√ß√µes distintas para voc√™:</p>
<ul>
<li><a href="#tipos-de-tipos-no-php">Tipos de tipos no PHP</a></li>
<li><a href="#operacoes-com-tipos-no-php">&quot;Opera√ß√µes&quot; com tipos no PHP</a></li>
<li><a href="#os-union-types">Os Union Types</a></li>
<li><a href="#malabarismo-de-tipos">Malabarismo de tipos, ou type juggling</a></li>
<li><a href="#modos-de-tipagem">Os modos de tipagem</a></li>
</ul>
<p>Se voc√™ tiver alguma sugest√£o de o que adicionar aqui, sinta-se livre pra
<a href="https://twitter.com/nawarian">me dar um toque no twitter</a> ou abrir uma
issue no github.</p>
<p><strong>Aahh!! Se voc√™ curte este tipo de conte√∫do mais aprofundado e tal, d√°
uma ligadinha nesse artigo que eu escrevi sobre
<a href="/br/edicao/php-8-jit">como funciona o Just In Time compiler</a>
que vai entrar no PHP 8.0! Abre numa abinha a√≠ e l√™ em seguida, tu n√£o vai
se arrepender! üòâ</strong></p>
<hr />
<h2 id="tipos-de-tipos-no-php">Tipos de tipos no PHP</h2>
<p>O sistema de tipos do PHP √© bem simplificado quando se trata de
funcionalidades da linguagem. Por exemplo, n√£o existe um tipo <em>char</em>,
ou valores <em>unsigned</em> (sem sinal) ou mesmo as varia√ß√µes de inteiro
<em>int8</em>, <em>int16</em>, <em>int32</em>, <em>int64</em>...</p>
<p>O tipo <em>char</em> √© simplificado para tornar-se <em>string</em> e todos inteiros
s√£o simplificados em um tipo <em>integer</em>. Se isso for ou n√£o uma coisa boa
fica a seu crit√©rio.</p>
<p>Voc√™ sempre pode inspecionar o tipo de uma vari√°vel usando a fun√ß√£o
<a href="https://www.php.net/manual/en/function.gettype">gettype()</a> ou
a fun√ß√£o <a href="https://www.php.net/manual/en/function.var-dump">var_dump()</a>.</p>
<p>O PHP vem com tr√™s tipos de tipos: <strong>tipos escalares</strong>, <strong>tipos compostos</strong>
e <strong>tipos especiais</strong>.</p>
<h3>Tipos escalares</h3>
<p>Tipos escalares s√£o fundamentais na linguagem e s√£o no total quatro:</p>
<ul>
<li>Boolean (<code>bool</code> | <code>boolean</code>)</li>
<li>Integer (<code>int</code> | <code>integer</code>)</li>
<li>Float (<code>float</code> | <code>double</code>)</li>
<li>String (<code>string</code>)</li>
</ul>
<p>Por defini√ß√£o, um tipo escalar n√£o possui comportamento ou estado.
Express√µes como <code>100-&gt;toString()</code> ou <code>'thephp.website'::length()'</code>
s√£o ilegais!</p>
<p><strong>Resum√£o do ENEM: tipos escalares n√£o possuem comportamento ou estado,
eles s√≥ representam um valor.</strong></p>
<h3>Tipos compostos</h3>
<p>Tipos compostos s√£o muito mais interessantes porque mesmo que eles sejam
similares aos tipos escalares, <strong>cada um dos quatro tipos compostos possui
diferentes sintaxes</strong>.</p>
<p>Os quatro tipos compostos s√£o:</p>
<ul>
<li><a href="#tipo-composto-array">array</a></li>
<li><a href="#tipo-composto-object">object</a></li>
<li><a href="#tipo-composto-callable">callable</a></li>
<li><a href="#tipo-composto-iterable">iterable</a></li>
</ul>
<h4 id="tipo-composto-array">O tipo composto Array</h4>
<p>Um array na realidade √© um hashmap, que vem por padr√£o com a linguagem PHP.
Isto significa que seus valores s√£o guardados no formato <strong>chave =&gt; valor</strong>
mesmo que voc√™ o utilize como um vetor.</p>
<p>Arrays s√£o estruturas muito flex√≠veis quando se trata de tamanho, tipos internos
e mapeamento chave-valor. Os exemplos abaixo s√£o todos arrays v√°lidos:</p>
<pre><code class="language-php">&lt;?php

$vec = [0, 1, 2];
// $vec[1] √© int(1)

$map = ['a' =&gt; 1, 'b' =&gt; 2];
// $map['a'] √© int(1)

$quase_map = ['a' =&gt; 1, 0 =&gt; 2];
// $quase_map['a'] √© int(1)
// $quase_map[0] =&gt; √© int(2)</code></pre>
<p>Diferente do C, o PHP n√£o vai te obrigar a definir o tamanho dos arrays
antes de cri√°-los. Isto, como era de se esperar, traz um custo em mem√≥ria:
o qu√£o maior for o tamanho do seu array, mais mem√≥ria voc√™ consumir√° em
propor√ß√µes absurdas (na real, arrays s√£o alocados em pot√™ncias de 2).
Como este consumo de mem√≥ria acontece est√° fora do escopo deste artigo,
<a href="https://twitter.com/nawarian">me d√° um toque se tu quiser saber mais sobre este t√≥pico em particular</a>.</p>
<p>Caso voc√™ esteja curioso sobre o que eu disse acima, tem uma apresenta√ß√£o
muito interessante do Nikita Popov sobre o consumo de mem√≥ria entre arrays
e objetos:</p>
<iframe style="margin: auto; margin-bottom: 20px;" width="560" height="315" src="https://www.youtube.com/embed/JBWgvUrb-q8?start=1000" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen><iframe style="margin: auto; margin-bottom: 20px;" width="560" height="315" src="https://www.youtube.com/embed/JBWgvUrb-q8?start=1000" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></iframe>
<p>Como voc√™ poder√° verificar abaixo, arrays tamb√©m s√£o considerados como sendo
do tipo <em>iterable</em>, isto significa que voc√™ pode iterar sobre eles usando um
la√ßo <em>foreach</em>. Mas eles tamb√©m oferecem
<a href="https://www.php.net/manual/en/ref.array.php">fun√ß√µes espec√≠ficas que podem manipular seus ponteiros internos</a></p>
<p><strong>Resum√£o do ENEM: O tipo array √© um tipo composto extremamente flex√≠vel e pode
ser considerado um HashMap e tamb√©m √© um tipo <em>iterable</em></strong></p>
<h4 id="compound-type-object">O tipo composto Object</h4>
<p>Por conta da arquitetura do PHP, o tipo composto <em>object</em> normalmente tem um perfil
de consumo de mem√≥ria bem menor quando comparado aos arrays. Isto porque <em>normalmente</em>
uma pessoa usaria o tipo object criando inst√¢ncias de classes.</p>
<p>Objetos podem carregar estado e comportamento consigo. Significa que o php oferece
sintaxes para desreferenciar as entranhas de um objeto. O snippet abaixo ilustra
como a opera√ß√£o de desrefer√™ncia funciona:</p>
<pre><code class="language-php">&lt;?php

class MinhaClasse
{
  private const A = 1;
  public int $propriedade = 0;
  public function metodo(): void {}
}

$obj = new MinhaClasse();
// $obj √© object(MyClass)
// $obj::A √© int(1)
// $obj-&gt;propriedade √© int(0)
// $obj-&gt;metodo() √© null</code></pre>
<p>Um objeto tamb√©m pode ser criado normalmente como resultado de um type cast a
partir de um array. Transformando as chaves do array em nomes de propriedades.
Este tipo de cast vai resultar em um tipo <code>object(stdClass)</code>.</p>
<pre><code class="language-php">&lt;?php

$obj = (object) ['a' =&gt; 1];
// $obj √© object(stdClass)
// $obj-&gt;a √© int(1)</code></pre>
<p>Vale ressaltar que converter um array com chaves num√©ricos em um objeto √© v√°lido,
mas n√£o √© poss√≠vel desreferenciar o seu valor porque propriedades de objetos
n√£o podem come√ßar com n√∫meros.</p>
<pre><code class="language-php">&lt;?php

$obj = (object) [0, 1]; // Legal
$obj-&gt;0; // Ilegal</code></pre>
<p><strong>Resum√£o do ENEM: objetos normalmente t√™m um perfil de mem√≥ria menor que o dos arrays,
carregam consigo estado e comportamento, e podem ser criados ao converter um array.</strong></p>
<h4 id="tipo-composto-callable">O tipo composto callable</h4>
<p>Um callable (cham√°vel) no php √© qualquer coisa que pode ser chamada (√© mermo √©?) usando
par√™ntesis ou com a fun√ß√£o <a href="https://www.php.net/manual/en/function.call-user-func.php">call_user_func()</a>.
Ou sejE, um callable √© capaz de cumprir o papel de o que conhecemos como fun√ß√µes. Fun√ß√µes
e m√©todos sempre s√£o callables. Objetos e classes tamb√©m podem se tornar callables.</p>
<p>Um callable pode, por defini√ß√£o, ser guardado numa vari√°vel. Como a seguir:</p>
<pre><code class="language-php">&lt;?php

$callable = 'strlen';</code></pre>
<p>Qu√™?! Mas isso n√£o √© uma string, doido!?</p>
<p>At√© que √©. Mas ele pode ser coagido (coerced) num callable se for necess√°rio. Como abaixo:</p>
<pre><code class="language-php">&lt;?php

function chameUmCallable(
  callable $f
): int {
  return $f('thephp.website');
}

$callable = 'strlen';

var_dump(
  $callable('thephp.website')
);
// int(14)

var_dump(
  chameUmCallable($callable)
);
// int(14)</code></pre>
<p>Callables tamb√©m podem apontar para um m√©todo de um objeto:</p>
<pre><code class="language-php">&lt;?php

class MinhaClasse
{
  public function meuMetodo(): int
  {
    return 1;
  }
}

$obj = new MinhaClasse();
var_dump([$obj, 'meuMetodo']());
// int(1)</code></pre>
<p>Parece estranho? Eu sei que tem cara de array. Na real √© um array mesmo. A n√£o ser que
voc√™ o trate como um callable üëÄ</p>
<p>Este tipo de callable acima (refer√™ncia de m√©todo de objeto) √© muito interessante porque
<strong>voc√™ pode chamar m√©todos privados ou protegidos</strong> com ele <strong>se voc√™ estiver dentro do
escopo da classe.</strong> Caso contr√°rio, voc√™ pode somente chamar m√©todos p√∫blicos.</p>
<p>E tamb√©m as classes que implementam
<a href="https://www.php.net/manual/en/language.oop5.magic.php#object.invoke">o m√©todo m√°gico __invoke()</a>,
automaticamente transforma suas inst√¢ncias em callables. Como a seguir:</p>
<pre><code class="language-php">&lt;?php

class MinhaClasseCallable
{
  public function __invoke(): int
  {
    return 1;
  }
}

$obj = new MinhaClasseCallable();
var_dump($obj());
// int(1)</code></pre>
<p><strong>Resum√£o do ENEM: callables s√£o refer√™ncias para fun√ß√µes ou m√©todos e podem ser constru√≠dos
de maneiras distintas.</strong></p>
<h4 id="tipo-composto-iterable">O tipo composto iterable</h4>
<p>Iterables s√£o muito mais simples de explicar: eles s√£o, por defini√ß√£o, um array ou uma inst√¢ncia
de <a href="https://www.php.net/manual/en/class.traversable.php">Traversable interface</a>. A coisa mais
importante de um iterable √© que ele pode ser usado num
<a href="https://www.php.net/manual/en/control-structures.foreach.php">la√ßo foreach()</a>, num
<a href="https://www.php.net/manual/en/language.generators.syntax.php#control-structures.yield.from">yield from</a>
ou com o <a href="https://wiki.php.net/rfc/spread_operator_for_array">operador de propaga√ß√£o (spread operator)</a>.</p>
<p>Exemplos de iterables s√£o:</p>
<pre><code class="language-php">&lt;?php

function funcao_generator(): Generator
{
  // ...
};

// Todas vari√°veis aqui s√£o iterables
$a = [0, 1, 2];
$b = funcao_generator();
$c = new ArrayObject();</code></pre>
<p><strong>Resum√£o do ENEM: se voc√™ pode colocar num foreach(), √© um iterable.</strong></p>
<h3>Tipos Especiais</h3>
<p>Existem dois tipos especiais. E a maior raz√£o pela qual eles s√£o chamados &quot;especiais&quot;
√© que <strong>n√£o √© poss√≠vel converter para estes tipos</strong>. Os tipos especiais s√£o o tipo
<strong>resource</strong> e o tipo <strong>NULL</strong>.</p>
<p><strong>Um resource representa um conector para um recurso externo</strong>. Que pode ser um conector
para um arquivo, um fluxo de E/S ou uma conex√£o com banco de dados. Voc√™ talvez possa
adivinhar o motivo de n√£o poder fazer um cast para qualquer outro tipo de resource.</p>
<p><strong>O tipo null representa um valor nulo</strong>. Isto significa que uma vari√°vel com NULL n√£o
foi inicializada, foi atribu√≠da com o valor NULL ou apagada em tempo de execu√ß√£o.</p>
<p><strong>Resum√£o do ENEM: uma vari√°vel de tipo especial n√£o pode ser convertida para qualquer outro tipo.</strong></p>
<h3>E as inst√¢ncias de classe?</h3>
<p>Inst√¢ncias possuem o tipo <code>object</code> e ser√£o sempre representadas desta forma. Chamar a fun√ß√£o
<a href="https://www.php.net/manual/en/function.gettype">gettype()</a> num objeto sempre ir√° retornar
o valor <code>string("object")</code> e chamar a fun√ß√£o <a href="https://www.php.net/manual/en/function.var-dump">var_dump()</a>
no mesmo objeto sempre ir√° imprimir seu valor usando a nota√ß√£o <code>object(NomeDaClasse)</code>. Se voc√™
precisar pegar a classe de um objeto no formato string, utilize a fun√ß√£o
<a href="https://www.php.net/manual/en/function.get-class">get_class()</a>.</p>
<pre><code class="language-php">&lt;?php

$obj = new stdClass();

echo gettype($obj);
// object

var_dump($obj);
// object(stdClass)#1 (0) {
// ...

echo get_class($obj);
// \stdClass</code></pre>
<h2 id="operacoes-com-tipos-no-php">"Opera√ß√µes" com tipos no PHP</h2>
<p>Existem diferentes &quot;opera√ß√µes&quot; que podem ser feitas com tipos no PHP. Eu acho
que √© importante deixar bem claro estas opera√ß√µes aqui para que n√£o misturemos
as bolas depois.</p>
<h3>Malabarismo de tipos (type juggling): cast e coer√ß√£o de tipos</h3>
<p>Antes de a gente se aprofundar, aqui v√£o tr√™s defini√ß√µes important√≠ssimas:</p>
<ol>
<li><strong>Convers√£o de tipo</strong> significa transformar um tipo de A para B. Por exemplo: de um inteiro para um float.</li>
<li><strong>Cast de tipos</strong> significa converter <strong>manual</strong> ou <strong>explicitamente</strong> um tipo de A para B. Como em <code>$cem = (int) 100.0</code>. (<code>float(100.0)</code> virou <code>int(100)</code>) </li>
<li><strong>Coer√ß√£o de tipo</strong> significa converter <strong>implicitamente</strong> um tipo de A para B. Como em <code>$vinte = 10 + '10 bananas';</code>. (<code>string("10 bananas")</code> virou <code>int(10)</code>)</li>
</ol>
<p>Tendo isto em mente, as pr√≥ximos sec√ß√µes v√£o explicar como isso funciona no php. E mais
pra frente voc√™ encontrar√° mais informa√ß√µes sobre o malabarismo de tipos (type juggling).</p>
<h4>Cast de tipos</h4>
<p>De forma semelhante ao Java, o PHP nos permite fazer cast de tipos. Isto significa que quando
uma vari√°vel aponta para um valor que pode ser transformado num tipo diferente, a linguagem
nos permite uma convers√£o manual (expl√≠cita) de tipos.</p>
<p>Pera, pera... √â O QUE!? ü§®</p>
<p>√ì: uma vari√°vel <code>$cem</code> segurando <code>string("100")</code> pode ser convertida manualmente (cast) para
tornar-se <code>int(100)</code> ou <code>float(100.0)</code> - ou qualquer outro tipo escalar ou um dos tipos
compostos <em>array</em> ou <em>object</em>.</p>
<p>O snippet a seguir funciona perfeitamente no PHP e √© bem parecido com o Java:</p>
<pre><code class="language-php">&lt;?php

$cem = (int) '100';
// $cem agora √© int(100)</code></pre>
<p>Agora, uma coisa que o Java faz e √© completamente ilegal no php, √© converter (cast) um ponteiro
de vari√°vel numa classe diferente. <strong>Isto significa que a gente s√≥ pode converter tipos escalares
e alguns tipos compostos no php</strong>:</p>
<pre><code class="language-php">&lt;?php

class MinhaClasse {}

// Gera um parse error
$ilegal = (MinhaClasse) new stdClass();</code></pre>
<p>Importante notar! No PHP s√≥ √© poss√≠vel fazer cast de tipos para tipos escalares*. Portanto
fazer o cast de um objeto para uma classe diferente √© ilegal, mas <strong>fazer um cast de objeto
para um tipo escalar √© completamente v√°lido</strong>.</p>
<p><strong>Tamb√©m poss√≠vel fazer o cast de valores para os tipos <em>array</em> ou <em>object</em></strong>, que n√£o s√£o
tipos escalares mas sim compostos (dar nome pr'esses coiso tudo √© osso, n√©?).</p>
<pre><code class="language-php">&lt;?php

class MinhaClasse {}

$obj = new MinhaClasse();
$um = (int) $obj; // int(1)</code></pre>
<p>O c√≥digo acima gera alguns notices mas ainda assim √© v√°lido. Mais tarde eu explico de onde
veio esse <code>int(1)</code>.</p>
<p><strong>Resum√£o do ENEM: o php permite realizar cast de tipos para escalares, arrays ou objetos.
Fazer o cast para classes n√£o √© permitido.</strong></p>
<h4>Coer√ß√£o de tipos</h4>
<p><strong>A coer√ß√£o de um tipo acontece como um efeito colateral de trabalhar com tipos incompat√≠veis
ou n√£o declarados.</strong> Eu explico melhor mais pra frente neste artigo. Por agora apenas confia que
o PHP vai automaticamente fazer o cast dos tipos o seu c√≥digo em tempo de execu√ß√£o quando necess√°rio.</p>
<p>Um exemplo de coer√ß√£o de tipos pode ser multiplicar um integer por um float. Na express√£o <code>int(100)</code>
multiplicado por <code>float(2.0)</code> o resultado √© um <code>float(200)</code>.</p>
<pre><code class="language-php">&lt;?php

var_dump(100 * 2.0);
// float(200)</code></pre>
<p><strong>Resum√£o do ENEM: o php tem um mecanismo para normalizar tipos em tempo de execu√ß√£o de forma
impl√≠cita e voc√™ deve sempre prestar aten√ß√£o nisso!</strong></p>
<h3>Type hints</h3>
<p>O type hinting √© um mecanismo de, ao mesmo tempo, refor√ßar a coer√ß√£o de tipos e de import tipagem
estrita. Isto foi introduzido ao php na vers√£o 7.0 e transforma assinaturas de m√©todos e fun√ß√µes.
<a href="https://wiki.php.net/rfc/typed_properties_v2">Desde o php 7.4 tamb√©m √© poss√≠vel fazer type hint com propriedades de classes</a>.</p>
<p>Abaixo vai um exemplo de type hint:</p>
<pre><code class="language-php">&lt;?php

function somar(
  int $a,
  int $b
): int {
  return $a + $b;
}</code></pre>
<p>As dicas (hints) aqui dizem que a vari√°vel <code>$a</code> √© do tipo <em>int</em> naturalmente ou transformada
pela linguagem, a vari√°vel <code>$b</code> tamb√©m √© do tipo <em>int</em> e o resultado desta fun√ß√£o ser√° do tipo
<em>int</em>, de forma natural ou transformada automaticamente pela linguagem (coer√ß√£o).</p>
<p>Reparou que eu disse que elas s√£o de certo tipo &quot;de forma natural ou transformada automaticamente
pela linguagem (coer√ß√£o)&quot;? Isso porque o PHP n√£o vai reclamar se voc√™ chamar esta fun√ß√£o
com valores que n√£o s√£o do tipo int. O que vai acontecer, ali√°s, √© que o php vai tentar converter
implicitamente (coer√ß√£o) os par√¢metros em inteiros se o tipo n√£o for o esperado.</p>
<p><strong>No corpo da fun√ß√£o a seguir voc√™ pode sempre ter certeza de que <code>$a</code> e <code>$b</code> s√£o inteiros. Mas
de que os inteiros est√£o corretos somente quem chama fun√ß√£o pode garantir.</strong></p>
<pre><code class="language-php">&lt;?php

function somar(
  int $a,
  int $b
): int {
  // $a √© int(10)
  // $b √© int(10)
  return $a + $b;
}

somar('10 ma√ß√£s', '10 bananas');</code></pre>
<p>Tamb√©m √© poss√≠vel ativar uma diretiva chamada <code>strict_types</code> para evitar coer√ß√µes e
simplesmente gerar erros quando tipos inv√°lidos s√£o utilizados. Como √† seguir:</p>
<pre><code class="language-php">&lt;?php

declare(strict_types=1);

function somar(
  int $a,
  int $b
): int {
  return $a + $b;
}

somar('10 bananas', '10 ma√ß√£s');
// PHP Fatal error: Uncaught
// TypeError: Argument 1 passed
// to somar() must be of the type
// int, string given</code></pre>
<p><strong>Isso n√£o significa que o php √© estaticamente tipado quando strict_types est√°
ligado!</strong> Na realidade, o type hinting apenas adiciona um processamento extra.
Internamente ele sempre far√° o malabarismo de tipos (type juggling) e nunca
ir√° confiar nos type hints da sua vari√°vel.</p>
<p>Type hints servem a dois prop√≥sitos: definir em quais tipos um valor deveria ser
coagido OU gerar erros fatais quando os strict types estiver ligado.</p>
<p><strong>Resum√£o do ENEM: type hints apenas d√£o dicas sobre os tipos para o php, n√£o ordens!
Usar strict types √© uma escolha que voc√™ pode tomar e trar√° um pequeno processamento
extra consigo.</strong></p>
<h2 id="union-types">Union Types</h2>
<p>Antes de a gente falar de malabarismo de tipos (type juggling) eu gostaria de falar
rapidinho sobre os Union Types porque parece fazer mais sentido aqui.</p>
<p>Al√©m dos tr√™s tipos que o php tem (escalares, compostos e especiais) o manual do php
tamb√©m menciona um
<a href="https://www.php.net/manual/en/language.pseudo-types.php">pseudo-tipo que s√≥ existe para facilitar a leitura do manual</a>.
Este tipo n√£o existe de verdade, √© apenas uma conven√ß√£o.</p>
<p>Eu gostaria que voc√™ prestasse aten√ß√£o num pseudo-tipo muito espec√≠fico: o <code>array|object</code>
normalmente √© utilizado na documenta√ß√£o para especificar par√¢metros ou tipos de retorno.</p>
<p>O tipo <code>iterable</code> tamb√©m √© um tipo de Union Type. E pode ser definido como <code>array|Traversable</code>.</p>
<p>Desde o php 7.1 a linguagem traz um meio-que suporte a Union Types ao ter introduzido
o <a href="https://wiki.php.net/rfc/nullable_types">nullable type</a>. Se voc√™ parar pra pensar,
um tipo nullable √© apenas um Union de <code>T|null</code>. Por exemplo, <code>?int</code> significa <code>int|null</code>.</p>
<p>Aposto que tu n√£o pensou sobre isso antes! üòù</p>
<p>Ent√£o depois de tantos Union Types desconhecidos,
<a href="https://wiki.php.net/rfc/union_types_v2">o php 8.0 formalmente implementou os Union Types</a>.
Onde voc√™ pode definir qualquer Union Type que precisar sem depender de pseudo-types ou
conven√ß√µes. Funciona mais ou menos assim: </p>
<pre><code class="language-php">&lt;?php

declare(strict_types=1);

function dividir(
  int $a,
  int $b
): int|float {
  return $a / $b;
}</code></pre>
<p>A fun√ß√£o acima pode retornar integer ou float. Mas nunca outro tipo.</p>
<h2 id="malabarismo-de-tipos">Malabarismo de tipos, ou type juggling</h2>
<p>Provavelmente n√£o √© a primeira vez que voc√™ ouviu falar no termo Type Juggling,
certo? Esta √© uma das funcionalidades mais importantes do php e, ainda assim, √©
uma das menos compreendidas.</p>
<p>Eu n√£o posso culpar ningu√©m por n√£o entend√™-la bem. A gente chama isso de &quot;malabarismo&quot;
por um bom motivo. Uma vari√°vel pode assumir tanto tipo diferente em cada contexto
que pode ser um tanto complicado entender com qual tipo voc√™ est√° lidando.</p>
<p>Vamos come√ßar com o seguinte: <strong>o php n√£o permite definir tipos explicitamente
na declara√ß√£o de vari√°veis</strong>. E isso √© muito poderoso!</p>
<p>Sempre que voc√™ declara uma vari√°vel, o php vai inferir o tipo que ela possui
baseado no valor que voc√™ a deu. Enquanto <code>$var;</code> cria uma vari√°vel com valor NULL,
<code>$one = 1</code> cria um inteiro e <code>$obj = new stdClass()</code> cria um <code>object(stdClass)</code>.</p>
<p>A√≠ n√£o tem defini√ß√£o de tipo em canto algum! O php vai tomar conta de adivinhar
qual o tipo melhor se adequa a sua vari√°vel.</p>
<p>As vari√°veis do php s√£o muito din√¢micas, de forma que elas podem mudar de tipo
em tempo de execu√ß√£o sem problema algum! O c√≥digo abaixo √© v√°lido:</p>
<pre><code class="language-php">&lt;?php

$var;
// $var √© NULL

$var = 1;
// $var √© int(1)

$var = 'thephp.website';
// $var √© string("thephp.website")

$var = new stdClass();
// $var √© object(stdClass)</code></pre>
<p>E por as vari√°veis serem t√£o din√¢micas, v√°rias opera√ß√µes no php exigem que os
valores sejam verificados baseado no contexto da opera√ß√£o. Uma express√£o como a
soma (a + b) internamente ir√° verificar o tipo do primeiro operando e depois tentar
adivinhar o tipo do segundo operando. </p>
<p>D√™ uma sacada <a href="https://github.com/php/php-src/blob/PHP-7.4/Zend/zend_vm_def.h#L47-L84">nesse snippet do c√≥digo fonte do php</a>.
Se <code>op1</code> for long (a √© um inteiro) ent√£o verifique se <code>op2</code> tamb√©m √© long (b √© inteiro).
Se sim, fa√ßa uma soma de longs. Se n√£o, verifique se <code>op2</code> √© um double e fa√ßa uma
soma de doubles se sim. E esta express√£o
<a href="https://github.com/php/php-src/blob/PHP-7.4/Zend/zend_vm_def.h#L61">pode retornar um inteiro</a>
ou <a href="https://github.com/php/php-src/blob/PHP-7.4/Zend/zend_vm_def.h#L74">um float</a>.</p>
<p><strong>E √© por isso que eu te garanto que o malabarismo de tipos (type juggling) vai acontecer
automaticamente.</strong></p>
<p>Isso tamb√©m significa que coer√ß√£o de tipos (convers√µes impl√≠citas) v√£o acontecer automaticamente.
Mas elas n√£o deveriam ser uma surpresa! H√° momentos muito espec√≠ficos onde uma coer√ß√£o
de tipos deve acontecer.</p>
<p>Coer√ß√£o de tipos (e, portanto, malabarismo de dados) ocorrem quando:</p>
<ul>
<li>resolvem-se express√µes</li>
<li>passam-se argumentos para uma fun√ß√£o ou m√©todo</li>
<li>retorna-se de uma fun√ß√£o ou m√©todo</li>
</ul>
<p>Voc√™ pode estar se perguntando: u√©, se coer√ß√£o acontece em todo canto ent√£o como
o php lida com tipos incompat√≠veis? Converter um inteiro para boolean parece normal,
mas um array para inteiro j√° come√ßa a ficar estranho.</p>
<p>Bem, o php tem regras muito bem definidas para fazer convers√£o de tipos. Primeiro
entende-se qual o tipo que o resultado deveria ter e s√≥ ent√£o √© feita a convers√£o.</p>
<p>Por exemplo, se uma express√£o ocorrer dentro de um <code>if()</code> a gente pode perceber
rapidinho que aquela express√£o deve resultar em um tipo boolean.</p>
<pre><code class="language-php">&lt;?php

$var = 100;
// $var √© int(100)

// $var √© tratado como
// boolean e resulta
// em TRUE
if ($var) {
  // $var ainda √© int(100)
}

// $var ainda √© int(100)</code></pre>
<p>Repare como $var era <code>int(100)</code> durante todo seu ciclo de vida, mas foi tratada como
<code>bool(TRUE)</code> dentro daquele <em>if()</em>. Isto ocorre porque o <em>if()</em> espera uma express√£o
que retorna um boolean. O malabarismo de tipos (type juggling) √© justamente o que o
php fez por debaixo dos panos para voc√™. </p>
<p>Para ilustrar, aqui vai a lista de verifica√ß√µes ao converter um tipo em boolean.
<strong>Uma convers√£o para boolean retorna false quando o valor original for</strong>:</p>
<ul>
<li>um bool(FALSE)</li>
<li>um <code>int(0)</code> ou <code>int(-0)</code></li>
<li>um <code>float(0)</code> ou <code>float(-0)</code></li>
<li>uma string vazia <code>string("")</code> ou a string zero <code>string("0")</code></li>
<li>um array vazio <code>array()</code></li>
<li>um NULL</li>
<li>uma inst√¢ncia de SimpleXML criada a partir de tags vazias</li>
</ul>
<p><strong>E ir√° retornar true para qualquer outro valor.</strong></p>
<p>A tabela acima pode ser encontrada na
<a href="https://www.php.net/manual/en/language.types.boolean.php#language.types.boolean.casting">se√ß√£o &quot;Converting to boolean&quot; do manual</a>.</p>
<p>A documenta√ß√£o completa sobre as compara√ß√µes de tipos e tabelas de convers√µes
<a href="https://www.php.net/manual/en/types.comparisons.php">tamb√©m podem ser encontradas no manual da linguagem</a>.
Eu n√£o tomei coragem de ler, mas faz parte do meu trabalho dizer que elas existem e
te mostrar onde ü§∑üèª‚Äç‚ôÄÔ∏è</p>
<p><strong>Nota importante aqui</strong>: no php 8.0 os union types foram introduzidos e trouxeram consigo
uma camada extra de complexidade. O malabarismo de dados (type juggling) quando lida com
Union Types precisa seguir uma regra de preced√™ncia. E essa preced√™ncia √© pr√©-definida em
vez de depender da ordem dos tipos declarados.</p>
<p><a href="https://wiki.php.net/rfc/union_types_v2#coercive_typing_mode">Ent√£o se voc√™ n√£o estiver usando strict_types os seus Union Types v√£o seguir esta regra</a>.
Se o Union Type n√£o cont√©m o tipo do resultado, ele poder√° fazer a coer√ß√£o deste valor na
seguinte ordem de preced√™ncia: <code>int</code>, <code>float</code>, <code>string</code> e <code>bool</code>.</p>
<p>Por exemplo:</p>
<pre><code class="language-php">&lt;?php

function f(
  int|string $v
): void {
  var_dump($v);
}

f(""); // string EST√Å no union type
// string("")

f(0); // int EST√Å no union type

f(0.0); // float N√ÉO EST√Å no union type
// int(0)

f([]); // array N√ÉO EST√Å no union type
// Uncaught TypeError:
// f(): Argument #1 ($v)
// must be of type string|int</code></pre>
<p>No exemplo acima algo interessant√≠ssimo acontece! O tipo array n√£o ser√° convertido
para um <code>bool(FALSE)</code>. Ele gera um TypeError em vez disso!</p>
<h2 id="modos-de-tipagem">Os modos de tipagem</h2>
<p><strong>Voc√™ j√° deve ter percebido que existem duas formas de o php lidar com tipos</strong>. Uma
delas √© chamada <strong>&quot;Coercive Type Mode&quot;</strong> onde acontece todo aquele malabarismo e
adivinha√ß√µes de tipos. A outra √© o <strong>&quot;Strict Type Mode&quot;</strong> onde <strong>o malabarismo e
a adivinha√ß√£o ainda acontecem</strong>, mas <strong>quando os tipos s√£o definidos explicitamente</strong>
alguns <strong>TypeErrors ser√£o lan√ßados quando os tipos n√£o forem compat√≠veis</strong>.</p>
<p>Agora, eu vejo como algo normal que pessoas programadoras de php possam esperar que a
linguagem respeite a Lei da Troca Equivalente (Á≠â‰æ°‰∫§ÊèõÊ≥ï) e lhe pague com ganho de
performance o esfor√ßo de usar strict types porque ela ser√° ent√£o capaz de pular todas
as verifica√ß√µes de tipos e executar as opera√ß√µes diretamente.</p>
<p>Ao passo que eu entendo o motivo de algu√©m pensar desta forma, eu preciso lhe dizer:
est√° completamente errado! O c√≥digo a seguir cont√©m
<a href="https://github.com/php/php-src/blob/PHP-7.4/Zend/zend_vm_def.h#L8056-L8105">a l√≥gica da fun√ß√£o strlen() no c√≥digo fonte do php</a>.</p>
<p>Toda vez que √© necess√°rio verificar se o php est√° operando no modo &quot;Strict Type&quot;, pode-se
buscar o boolean a partir da chamada <code>EX_USES_STRICT_TYPES()</code>. Se true, o strict types
est√° ligado. Se n√£o, o modo coercivo est√°.</p>
<p>Agora, veja o snippet novamente! Ele come√ßa assim:</p>
<pre><code class="language-c">// ...
zval *value;

value = GET_OP1_ZVAL_PTR_UNDEF(BP_VAR_R);
// value √© o par√¢metro
// de strlen()

if (EXPECTED(
  Z_TYPE_P(value) == IS_STRING
)) {
  ZVAL_LONG(
    EX_VAR(
      opline-&gt;result.var
    ),
    Z_STRLEN_P(value)
  );
  FREE_OP1();
  ZEND_VM_NEXT_OPCODE();
} else {
  // ...
}</code></pre>
<p>Reparou naquele primeiro <em>if()</em> al√≠? Adivinha o que ele t√° fazendo... EXATO! Ele
verifica pra ti o tipo do par√¢metro!!</p>
<p>Sabe o que esse mesmo trecho de c√≥digo est√° fazendo com o seu type hint? NADINHA! ü§£</p>
<p>A cl√°usula <em>else</em> possui o c√≥digo TALVEZ v√° usar strict types ou n√£o.</p>
<pre><code class="language-c">// ...
} else {
  // Ok, estamos progredindo
  zend_bool strict;

  // üò≠
  if (
    (OP1_TYPE &amp; (IS_VAR|IS_CV)) &amp;&amp;
    Z_TYPE_P(value) == IS_REFERENCE
  ) {
      // ...
  }

  // ...

  // OPA! üëÄ
  strict = EX_USES_STRICT_TYPES();
  do {
    if (EXPECTED(!strict)) {
      // ...
    }
    zend_internal_type_error(
      strict,
      /*...*/
    );
    ZVAL_NULL(
      EX_VAR(opline-&gt;result.var)
    );
  } while (0);
}</code></pre>
<p>No trecho acima podemos ver um exemplo de como o modo strict type n√£o corta nenhum
processamento. Na verdade, acabou criando algumas verifica√ß√µes a mais com um √∫nico
prop√≥sito: gerar erros fatais. </p>
<p>Eu n√£o quero dizer que esta √© uma implementa√ß√£o ruim. Eu pessoalmente estou bem
contente com a forma que o php funciona. Mas eu acho que √© importante deixar claro
que isto n√£o ir√° afetar a performance de forma positiva.</p>
<p><strong>Resum√£o do ENEM: strict types n√£o tornar√£o seu c√≥digo mais r√°pido!</strong></p>
<h2>Conclus√£o</h2>
<p>Esse artigo deu trabalho ein! Me fez considerar um bom tanto a ideia de escrever um livro.
S√≥ este artigo j√° daria uns 15% de um livro bacana üòÇ</p>
<p>Eu espero que a informa√ß√£o que eu coletei aqui foi √∫til pra ti. E se n√£o foi, que tenha
sido ao menos interessante.</p>
<p>Eu acredito que o sistema de tipos do PHP √© incrivelmente rico e carrega v√°rias funcionalidades
legadas e tamb√©m inovadoras e todas elas fazem muito sentido quando voc√™ olha para a
hist√≥ria do desenvolvimento da linguagem.</p>
<p>Como sempre, sinta-se livre para me dar um al√¥ no twitter se voc√™ tiver algo a dizer. Voc√™
tamb√©m pode abrir uma issue ou pull request no github e ser feliz.</p>
<p><strong>Resum√£o do ENEM: deu um trabalh√£o da penga escrever E TRADUZIR este artigo. Se voc√™ quiser
dar aquela for√ßa, por favor compartilhe em seus c√≠rculos e m√≠dias sociais üôè</strong></p>
<p>At√© a pr√≥xima! Valeu!</p>
<div class="align-right">
  --
  <a href="https://twitter.com/nawarian" rel="nofollow">
    @nawarian
  </a>
</div>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "Tudo o que voc&ecirc; precisa (e n&atilde;o precisa) saber sobre Tipos no PHP",
  "description": "Este &eacute; o melhor guias entre todos que voc&ecirc; encontrar&aacute; na internet sobre como o PHP lida com seus tipos internamente.",
  "image": [
    "https://thephp.website/assets/images/posts/17-php-type-system-640.webp"
   ],
  "datePublished": "2020-07-25T00:00:00+08:00",
  "dateModified": "2020-07-25T00:00:00+08:00",
  "author": {
    "@type": "Person",
    "name": "Nawarian N&iacute;ckolas Da Silva"
  },
   "publisher": {
    "@type": "Organization",
    "name": "ThePHP Website",
    "logo": {
      "@type": "ImageObject",
      "url": "https://thephp.website/favicon.ico"
    }
  }
}
</script>  </div>
  </article>
</body>
<script src="/assets/build/js/main.js?id=fd09420d5a6aa331aa18"></script>
</html>
