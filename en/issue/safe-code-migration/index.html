<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <link rel="stylesheet" href="/assets/build/css/main.css?id=2e42c8808e21522a0c4d">
      <link rel="canonical" href="https://thephp.website/en/issue/safe-code-migration/" />
      <link
    rel="alternate"
    type="application/json"
    title="[EN] thePHP Website"
    href="https://thephp.website/en/feed.json"
  />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="[EN] thePHP Website"
    href="https://thephp.website/en/feed.xml"
  />
  
  <title>How to safely migrate a database or field in 9 steps | thePHP Website</title>

  <meta name="description" content="I’m writing about a very specific and hairy problem: unique id migration.">

  <meta property="og:title" content="How to safely migrate a database or field in 9 steps">
  <meta property="og:description" content="I’m writing about a very specific and hairy problem: unique id migration.">
  <meta property="og:url" content="https://thephp.website/en/issue/safe-code-migration">
  <meta property="og:image" content="https://thephp.website/assets/images/posts/23-safe-code-migration-640.webp">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@nawarian">
  <meta name="twitter:title" content="How to safely migrate a database or field in 9 steps">
  <meta name="twitter:description" content="I’m writing about a very specific and hairy problem: unique id migration.">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151169766-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-151169766-3');
  </script>
  <script data-ad-client="ca-pub-3681134868307419" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- Hotjar Tracking Code for thephp.website -->
  <script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1770868,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
  </script>
  <script>
    function toggleMenu() {
      document.querySelector('.menu__container').classList.toggle('menu__container--active');
    }
  </script>
</head>
<body class="yue non-article">
  <header class="menu">
    <a class="menu__logo" href="/en/">
      <img src="/assets/images/elephpant-idle.png" alt="" />
    </a>
    <div class="menu__title">
      <a href="/en/">thePHP Website</a>
    </div>
    <section class="menu__cta">
      <button role="button" aria-label="Open Menu" class="menu__cta__icon" onclick="typeof toggleMenu == 'function' &amp;&amp; toggleMenu()">
        <img alt="Open Menu" src="https://podentender.com.br/assets/images/icons/menu.svg">
      </button>
    </section>

    <div class="menu__container">
      <em class="menu__section-heading">
        Pages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/en/">Home</a>
        </li>
        <li class="menu__list-item">
          <a href="/en/search">
            search.php
          </a>
        </li>
        <li class="menu__list-item">
          <a
            href="https://github.com/nawarian/The-PHP-Website/issues/new?title=[Suggested+Topic]%20&body=Please+describe+your+suggestion+/+Por+favor+descreva+sua+sugestão"
            rel="nofollow"
          >
            Suggest a Topic!
          </a>
        </li>
        <li class="menu__list-item">
          <a href="/en/about/">
            about.php
          </a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Languages.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="/en/">English</a>
        </li>
        <li class="menu__list-item">
          <a href="/br/">Português</a>
        </li>
      </ul>

      <hr>
      <em class="menu__section-heading">
        Notifications.php
      </em>
      <ul class="menu-list">
        <li class="menu__list-item">
          <a href="https://thephp.website/en/feed.json">
            [EN] JSON Feed
          </a>
        </li>
        <li class="menu__list-item">
          <a href="https://thephp.website/en/feed.xml">
            [EN] Atom Feed (RSS)
          </a>
        </li>
              </ul>
    </div>
  </header>
  <article class="container">
      <div class="article">
    <time datetime="2021-12-04">
      2021-12-04
    </time>

    <h1>How to safely migrate a database or field in 9 steps</h1>
    <p><a href="https://codamos.com.br/migracao-banco-de-dados.html">Leia em Português</a></p>

<p>I was writing another post about Feature Flags and decided to use an example that actually required way more than just feature flags. So I’ll just write about it first and maybe I can talk about feature flags exclusively another moment.</p>

<h2>The problem</h2>

<p>I’m writing about a very specific and hairy problem: unique id migration.</p>

<p>We have an entity <code>User</code>, identified by <code>User::$id</code> that looks like this:</p>

<pre><code>final class User
{
  public function __construct(
    public int $id,
  ) {}
}
</code></pre>

<p>And the way you access data from it, is via a repository interface named <code>UserRepository</code>. I’ll drop here a simple Sqlite implementation of this repository too:</p>

<pre><code>interface UserRepository
{
  /**
   * @throws  UserNotFoundException
   */
  public function findById(
    int $id
  ): User;
}

final class SqliteUserRepository
  implements UserRepository
{
  public function findById(
    int $id
  ): User {
    $sql = "...";
    $stmt = $this-&gt;pdo-&gt;prepare($sql);
    $stmt-&gt;execute([
      'id' =&gt; $id,
    ]);
    // ...
  }
}
</code></pre>

<p>Pretty simple set up.</p>

<p>Now let’s say that your team decided that a User’s unique identifier, for security reasons, should no  longer be an integer but an UUID should be adopted instead.</p>

<p>Of course no downtime is not acceptable.</p>

<h2>The solution</h2>

<p>To be super safe, I’ll implement it in three phases:</p>

<ol>
<li>Let both ids coexist</li>
<li>Battle test the UUID implementation</li>
<li>Decommission the former integer id implementation</li>
</ol>

<p>The main reason why I’d like to make it happen in different phases, is that tests aren’t enough to make sure everything works as expected. This field might be used by other jobs via API or something I can’t even imagine right now.</p>

<p>So just in case, I’d like to be able to safely rollback to the previous implementation at any given moment.</p>

<p><strong>I’m assuming every step I describe here is properly covered with tests, ideally before the refactoring happens.</strong></p>

<h2>Step 1 - Decouple from primitive types</h2>

<p>Whatever you do next, it won’t be easy without this! That <code>int</code> primitive type in the <code>User</code> class is asking for explosions to happen.</p>

<p>If you want to smoothly transition away from integer to UUID, your best shot will be to first decouple your code from primitives. A way to do it is by encapsulating your primitives. I’m gonna create a class named <code>UserId</code> and let the code depend on it instead of <code>int</code>:</p>

<pre><code>final class UserId
{
  public function __construct(
    public int $id,
  ) {}

  public function getId(): int
  {
    return $this-&gt;id;
  }
}

final class User
{
  public function __construct(
    public UserId $id,
  ) {}
}

interface UserRepository
{
  /**
   * @throws  UserNotFoundException
   */
  public function findById(
    UserId $id
  ): User;
}
</code></pre>

<p>The above should make refactoring slightly easier. <code>UserId</code> still returns <code>int</code> when <code>getId()</code> is called, but that’s fine! What matters the most is that our code depends on <code>UserId</code> - a type we control - instead of the primitive <code>integer</code> - which we don’t control at all.</p>

<p>Now just cover all existing code to use <code>UserId</code> instead of <code>int $id</code>.</p>

<pre><code>final class SqliteUserRepository
  implements UserRepository
{
  public function findById(
    UserId $id
  ): User {
    $sql = "...";
    $stmt = $this-&gt;pdo-&gt;prepare($sql);
    $stmt-&gt;execute([
      'id' =&gt; $id-&gt;getId(),
    ]);
    // ...
  }
}
</code></pre>

<p>Until here, nothing changed. We’re just setting up the stage.</p>

<p>This feels safe to be merged and deployed, and nothing should break. Tests help a lot, by the way. Do not skip them!</p>

<h2>Step 2 - Let both fields coexist</h2>

<p>Now let’s make sure that we can add a new field to our <code>Users</code> table. Something like this would do:</p>

<pre><code>sqlite&gt; ALTER TABLE `users` ADD `uuid` VARCHAR;
</code></pre>

<p>It can be neither  <code>NOT NULL</code> nor <code>UNIQUE</code> for now, because every existing record will have it with a <code>NULL</code>.</p>

<p>Back to our <code>UserId</code> class, let’s make sure it now has <code>uuid</code> in its implementation:</p>

<pre><code>final class UserId
{
  public function __construct(
    public int $id,
    public ?UuidInterface $uuid,
  ) {}

  public function getId(): int
  {
    return $this-&gt;id;
  }

  public function getUuid(): ?UUidInterface
  {
    return $this-&gt;uuid;
  }
}
</code></pre>

<p>It is still nullable because, well, it is null in the database!</p>

<p>Now we need to make sure two things happen:</p>

<ol>
<li>Every existing record will have a non-null uuid; and</li>
<li>Every new record will already come with a filled uuid</li>
</ol>

<p>We consider both are coexisting just fine in the database layer, when we see that at any given moment, <code>users.uuid</code> is never <code>NULL</code>.</p>

<h2>Step 3 - Make sure every new record has an UUID</h2>

<p>Somewhere in your system something stores Users. We need to make sure that everywhere where it happens, the UUID field will be populated.</p>

<p>So given this older implementation:</p>

<pre><code>...

public function insert(
  User $user
): void {
  // insert into ...
}

...
</code></pre>

<p>I’d just patch it with UUID generation and we should be fine:</p>

<pre><code>...

public function insert(
  User $user
): void {
  $id = $user-&gt;id;

  if ($id-&gt;uuid === null) {
    $id-&gt;uuid = Uuid::uuid4();
  }

  // insert into ...
}

...
</code></pre>

<p>I highly recommend you to cover this IF statement with tests, just in case you missed an import or something like that. Apart from that, no other regressions should have been introduced.</p>

<p>Every new record should now have <code>users.uuid</code> properly filled.</p>

<h2>Step 4 - Backfill UUID field for older records</h2>

<p>This can be done with a script. If you use a migration framework, it will probably be super easy too.</p>

<p>We just need to fetch all users with null uuids and fill them. Something like this would do the trick:</p>

<pre><code>$users = getUsersWithEmptyUuid();
foreach ($users as $user) {
  $user-&gt;id-&gt;uuid = Uuid::uuid4();
  updateUser($user);
}
</code></pre>

<p>The above is not very representative of every codebase, but I suppose you got the point.</p>

<h2>Step 5 - Make sure everything is up and running</h2>

<p>Do not rush to switch the implementations just yet. Let’s make sure the system is up and running, and that <code>users.uuid</code> won’t be <code>NULL</code> after running the system for a couple of hours more.</p>

<p>Only move to the next step when you are 100% safe that <code>users.uuid</code> won’t ever be <code>NULL</code> in this table.</p>

<h2>Step 6 - Update UserRepository to use UUID</h2>

<p>It seems we’re already in the position to switch to the new UUID implementation. <strong>I don’t recommend blindly switching to the new implementation just yet</strong>.</p>

<p>Better safe than sorry, right? Let’s make sure we protect our code with a feature flag. Let’s update the <code>SqliteUserRepository</code> with the following:</p>

<pre><code>final class SqliteUserRepository
    implements UserRepository
{
  public function findById(UserId $id): User
  {
    if (
      isFeatureFlagActive('enableNewUsersUuidImplementation')
    ) {
      // New implementation, using Uuid
      $sql = "...";
      $stmt = $this-&gt;pdo-&gt;prepare($sql);
      $stmt-&gt;execute([
        'uuid' =&gt; (string) $id-&gt;getUuid(),
      ]);
      // ...
    } else {
      // Old implementation, using integer $id
      $sql = "...";
      $stmt = $this-&gt;pdo-&gt;prepare($sql);
      $stmt-&gt;execute([
        'id' =&gt; $id-&gt;getId(),
      ]);
      // ...
    }
  }
}
</code></pre>

<p>Long story short: <code>isFeatureFlagActive()</code> returns <code>TRUE</code> if the feature we requested is enabled and <code>FALSE</code> if not. It can be based on configurations, database entries or environment variables. This is not relevant here.</p>

<p><strong>It is important that you can change the return value of <em>isFeatureFlagActive()</em></strong> <strong>without having to redeploy your code.</strong> This way you can safely rollback to the previous implementation without much friction.</p>

<h2>Step 7 - Deploy, enable and monitor</h2>

<p>First deploy it making sure that <code>isFeatureFlagActive()</code> will always return <code>FALSE</code> so the original implementation is picked up.</p>

<p>Then switch <code>isFeatureFlagActive()</code> to return <code>TRUE</code>, so the new implementation will be picked up - Again, this could be done via database records, environment variables, SaaS tools or anything you fancy.</p>

<p><strong>Oh no! Something 's wrong! The website is suddenly super slow!!</strong></p>

<p>Switch off your feature flag, so <code>isFeatureFlagActive()</code> will return <code>FALSE</code> again.</p>

<p>...</p>

<p>Things seem to be normal again. Go back to your IDE and try to figure out what happened. Maybe do some clickthrough and debug things to understand what is causing it to be so slow.</p>

<p>Eventually you’ll realise that you did not index the <code>users.uuid</code> column, so querying it became super slow because of your ginormous table. Let 's fix it!</p>

<h2>Step 8 - Make UUID unique and index it</h2>

<p>As I’m using SQLITE implementation, here’s the snippet that should do the trick:</p>

<pre><code>sqlite&gt; CREATE UNIQUE INDEX `users_uuid_uq` ON `users`(`uuid`);
</code></pre>

<p>Ideally you should also make <code>users.uuid</code> NOT NULL, but I’m skipping it because it requires more steps for SQLITE that are not relevant to what I want to demonstrate here.</p>

<p>Alright, things should be fine now. Propagate your changes to production and see how the feature flagged code behaves now.</p>

<p>All good, right? It is time to clean things up.</p>

<h2>Step 9 - Clean up your numeric id</h2>

<p>Now that things are deployed and battle tested, it is time to clean up the previous numeric id field.</p>

<p>Whether you’re removing the actual field or just not using it in code is a project decision - and what wasn’t, right?</p>

<p>But eventually your <code>SqliteUserRepository</code> would look like this:</p>

<pre><code>final class SqliteUserRepository
    implements UserRepository
{
  public function findById(
    UserId $id
  ): User {
    $sql = "...";
    $stmt = $this-&gt;pdo-&gt;prepare($sql);
    $stmt-&gt;execute([
      'uuid' =&gt; (string) $id-&gt;getUuid(),
    ]);
    // ...
  }
}
</code></pre>

<p>The function that inserted records also deserves some love now. Let’s remove the former IF statement:</p>

<pre><code>...

public function insert(
  User $user
): void {
  $user-&gt;id-&gt;uuid = Uuid::uuid4();

  // insert logic
}

...
</code></pre>

<p>And if you have decided to remove the numeric id from the database too, let’s make sure the <code>UserId</code> code is also cleaned up and remove the <code>$id</code> property:</p>

<pre><code>final class UserId
{
  public function __construct(
    public UuidInterface $uuid,
  ) {}

  public function getUuid(
  ): UuidInterface {
    return $this-&gt;id;
  }
}
</code></pre>

<p>And because there’s absolutely no reason for UUID to be nullable now, I just removed the question marks from the <code>$uuid</code> property too.</p>

<h2>Go grab a snack and reward yourself: your system is safe!</h2>

<p>Of course things can differ from project to project, but at the end of the day, you’ll be executing some variation of the described technique.</p>

<p>This applies to pretty much any data-dependent implementation change. Just remember the three phases:</p>

<ol>
<li>Let both implementations coexist</li>
<li>Battle test the new implementation</li>
<li>Decommission the former implementation</li>
</ol>

<p>Don’t be shy or ashamed of taking multiple steps. Even if you know you’ll have to delete code afterwards!</p>

<p>Rolling back a deployment or fixing a live database as a reaction to an issue are way more painful than any of the steps I’ve described here.</p>

<div class="align-right">
  --
  <a href="https://twitter.com/nawarian" rel="nofollow">
    @nawarian
  </a>
</div>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "Safe code migration",
  "description": "I’m writing about a very specific and hairy problem: unique id migration.",
  "image": [
    "https://thephp.website/assets/images/posts/23-safe-code-migration-640.webp"
   ],
  "datePublished": "2021-12-04T00:00:00+08:00",
  "dateModified": "2021-12-04T00:00:00+08:00",
  "author": {
    "@type": "Person",
    "name": "Nawarian Níckolas Da Silva"
  },
   "publisher": {
    "@type": "Organization",
    "name": "ThePHP Website",
    "logo": {
      "@type": "ImageObject",
      "url": "https://thephp.website/favicon.ico"
    }
  }
}
</script>
  </div>
  </article>
  <aside class="container">
          <div class="recommended">
      <h3>Keep reading</h3>
      <ul class="card-list">
                  <li class="card">
            <a href="https://thephp.website/en/issue/how-to-compile-php/">
                              <div
                        class="card__image"
                        style="background-image: url(/assets/images/posts/22-compiling-php-from-source-code/cover.png)"
                        alt="A screen displaying PHPs compiling process."
                ></div>
              
              <div class="card__content">
                <h4>How to compile PHP from Source</h4>
                <p>I write this short guide as an effort inspired by Joe Watkins&#039; (krakjoe) post on the existing Bus Factor present in the PHP language. Knowing how to compile PHP will open one of the few doors necessary for contributing to the PHP language. Once you get familiar with this it will be much easier for you to contribute in many ways.</p>
                <time>2021-05-24</time>
              </div>
            </a>
          </li>
                  <li class="card">
            <a href="https://thephp.website/en/issue/php-ffi/">
                              <div
                        class="card__image"
                        style="background-image: url(/assets/images/posts/21-php-ffi-640.webp)"
                        alt="A human shape painted with zeros and ones."
                ></div>
              
              <div class="card__content">
                <h4>Complete guide to FFI in PHP</h4>
                <p>By using FFI your PHP programs will be able to use libraries written in C, Rust, Golang or any other language capable of producing an ABI. Here&#039;s how!</p>
                <time>2021-03-11</time>
              </div>
            </a>
          </li>
              </ul>
    </div>
    </aside>
</body>
<script src="/assets/build/js/main.js?id=2c0b2b79fd6e188ff54c"></script>
</html>
