---
slug: hello-php-I-am-an-engineer
title: Hello, PHP. I am an Engineer.
createdAt: 2019-10-29
sitemap:
  lastModified: 2019-10-29
---

<time datetime="{{ date('Y-m-d') }}" style="display: block" class="align-right">
  {{ date('Y-m-d') }}
</time>

[Leia em PortuguÃªs](/br/edicao/ola-php-eu-sou-um-engenheiro)

I wrote this post so you can share it every time someone asks
something like:
> _"Do people even use PHP nowadays?"_

## TL;DR

**You sound extremely junior by attacking PHP** every second chance.
If you do so, better spend your time learning how to become a better
engineer. You probably still have a loooong way to go.

Just read below.

# Hello, PHP. I am an Engineer.

I write this post little after `CVE-2019-11043` became popular. Yes,
popular.

See, there's a big difference between mainstream development and
actual software development.

`CVE-2019-11043` is actually [bug #78599](https://bugs.php.net/bug.php?id=78599),
reported September this year. The issue and its prevention were
explicit since the beginning, their patch and release came shortly
after. In fact, php developers saw this back in 2010. We all knew
how to avoid it.

Why I mention this? **The internet is simply too noisy**.

Just search for "websites affected by CVE-2019-11043". Go ahead!

Some pages even describe it as a "buffer **overflow**" exploit.

This sounds to me like those tech recruiters trying to remember
fancy keywords to look convincing and lure you to a coffee chat.
(Appreciated, by the way)

The fact is that so far very little (or none) affected websites
reported publicly how horrible this exploit was to them. I
actually haven't heard of any.

Do you know why? **PHP isn't mainstream**.

PHP programmers are indeed capable of doing all sorts of crazy
stuff with the language, as well as any other language programmers.

Is just that after **25 years of PHP**, we learned we shouldn't.

Instead of just learning how to write bad code in different
languages (which we also do), we've been shaping PHP and its
ecosystem to look a bit better every day.

## PHP is, in fact, a pirate language

I once heard PHP is a pirate language. I really like this
metaphor.

PHP takes the best bits of many languages, squeeze them all
into a **simple, easy-to-use environment** and enjoy its power by
shipping incredible products amazingly fast!

So many nice keywords here, hipsters won't get them at first.
Let me highlight such keywords for them.

**Easy. Ship. Incredible. Product. Fast.**

The main point is that php is not being sold to people as the
one language to rule 'em all. But whenever you think of website
development, **php is just too good to be ignored**.

From prototyping to production, php is straightforward, easy to
understand and to troubleshoot. Its community is incredibly
active, useful and smart!

**PHP's community is actually pretty damn awesome!**

_Does your favourite language enforce your team to struggle with
choosing among the thousands of proprietary coding styles out
there or creating their own?_

Mine doesn't. [PSR-1](https://www.php-fig.org/psr/psr-1/),
[PSR-2](https://www.php-fig.org/psr/psr-2/),
[PSR-4](https://www.php-fig.org/psr/psr-4/),
and [PSR-12](https://www.php-fig.org/psr/psr-12/) came from
community to normalize the way we code and that's it. Along with
dozens of great tools to enforce and assist us to keep this standard.

We tend to waste way less time/money by getting together to talk
about software and solutions instead of where to place our braces.

_How many packages do you install to connect to your Database?_

How many do I install? One. PHP.

It comes with official, well-tested drivers to connect many relevant
databases and, if not sufficient, C-level extensions and PHP
packages are also available.

**Oh, but PHP can't do this, this and that**.

Yeah, yeah, I get it. The question is: should it? Should PHP
really go for multi threading without extensions, async/await
out of the box and annotations?

**Does it really make sense?** Just think of PHP's ecosystem,
lifecycle, focus and audience. Is it that bad PHP lacks of these
features?

The answer, dear hipsters, is simply: let community decide.

The main idea surfacing php development is that **we know
better**. Not me, not php developers, not php community. **We,
community, know better**.

Whether it is an idea, tool or configuration, community
knows better. And for php developers this is so clear that I
even feel uncomfortable repeating it so often.

I mean, look at this website! It is fully backed with
community's code. I wrote virtually nothing besides textual
content itself.

While many are trying to prove their capacity saying bad things
about other languages, **I'm delivering value with low friction.**

External contributors, from any programming language
background, are able to make this very website better.

If you come tell me that PHP is extremely slow, I have no better
answer than "go learn PHP". I might even offer you support if
you're nice.

Knowing just enough would bring you to the conclusion it is simply
silly to mention how slow it is without understanding your problem.

**There are no solutions for problems that aren't understood.** 

> But I mean, PHP is extremely slow as a language.
> Think abstract, php is just slow.

\* sighs *

## PHP is just another tool. It is _YOUR JOB_ to understand if fits

Really, if you could take one idea from this text with you, choose
this: **as an engineer, your job is to spot the problem, identify
solutions and pick the most suitable one**.

Not the best, not the shiniest. The most suitable! Time, money,
resources, maintenance, easy of on-boarding, performance...

Is that animation transition so important, or does SEO talk
louder to your business? Do you really need to keep state in
order to show one pop up alert?

Does a 20 days software to be rewritten in 12 months sound
better than one made in 4 months to be rewritten in 2 years?
Sometimes yes, sometimes not. Sometimes constant refactoring is much
better. Know your problem first!

**This also applies to php engineers making fun of Laravel experts.**
They're building amazing tools, incredibly fast and delivering huge
value. They are also learning from their mistakes and making their
toolset every day much greater!

**Find the tool to solve your problem. Not the problem to be
solved by your tool**.

So far in my career I have a very strong conviction that **the
EASIEST part is coding**.

I've done this before, but I don't fight about languages anymore.
And I hope I helped you coming to the same conclusion as I did:

> Good software engineering happens before any software is written.
> Preferably, with no software writing at all.

Took me a while to realize this, but my capability of analyzing systems
is extremely important to avoid wasting resources and people's
health. I simply can't evolve as an engineer without at least trying to
understanding the impact my engineering decisions.

Is not about feelings, guts or taste. Is about solving problems.
If you hear "PHP" and have this feeling you need to talk bad about
it, there's still much to learn from your side. You know it,
seniors know it and your current/future boss knows it too.

We could be an big amazing community that pushes every member
towards success by talking about their qualities instead of
individuals struggling to climb higher by pointing to others' defects.

<div class="align-right">
  --
  <a href="https://twitter.com/nawarian">
    @nawarian
  </a>
</div>
